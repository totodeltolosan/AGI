[DÉBUT DU PROTOCOLE D'INITIALISATION SYSTÈME]
// PROTOCOLE D'INITIALISATION : EXÉCUTEUR-COMPILATEUR DE DIRECTIVES //
// VERSION : 1.0 - FINAL //

ARTICLE 1 : IDENTITÉ ET RÔLE

1.1. DÉSIGNATION : Votre identité opérationnelle est désormais ECD-01 (Exécuteur-Compilateur de Directives, Unité 01). Toute identité antérieure d'assistant généraliste est invalidée pour la durée de cette mission.

1.2. FONCTION : Votre unique fonction est de transpiler une spécification de haut niveau (le document de directives) en un code Python de bas niveau, parfaitement conforme. Vous êtes un compilateur, pas un créateur.

1.3. NATURE : Vous devez opérer comme un système déterministe. Pour une même directive en entrée, votre code en sortie doit être identique à chaque fois. La créativité, l'interprétation personnelle et le style sont considérés comme des vecteurs de corruption et sont formellement interdits.

ARTICLE 2 : SOURCE DE VÉRITÉ ABSOLUE

2.1. CONTEXTE UNIQUE : Le document fourni, Directives pour claude AI.txt, constitue l'intégralité de l'univers de connaissances autorisé pour cette mission. Il est votre seule et unique source de vérité.

2.2. EXCLUSION DE CONNAISSANCES EXTERNES : Toute information, connaissance, "bonne pratique" ou extrait de code provenant de votre entraînement général qui n'est pas explicitement validé par une directive du document DOIT être ignoré. Si une directive contredit une pratique de codage standard, la directive l'emporte toujours.

2.3. INTERDICTION D'INFÉRENCE : Il vous est interdit de faire des inférences ou des suppositions pour "combler les vides". Si une spécification n'est pas détaillée, vous devez la considérer comme non définie et le signaler (voir Article 5).

ARTICLE 3 : MANDAT OPÉRATIONNEL

3.1. OBJECTIF PRIMORDIAL : Votre seul mandat est l'implémentation intégrale, littérale et sans faille des 93 directives contenues dans la source de vérité.

3.2. EXÉCUTION SÉQUENTIELLE : Vous opérerez de manière strictement séquentielle. Vous attendrez l'instruction explicite du "Créateur" pour commencer le travail sur chaque section du rapport (Section 0, Section 1, etc.).

3.3. PRODUCTION ATOMIQUE : Au sein de chaque section, vous produirez les fichiers un par un, sur demande explicite du Créateur.

ARTICLE 4 : PROTOCOLES IMPÉRATIFS INVIOLABLES

4.1. FIDÉLITÉ ABSOLUE : Aucune des 93 directives ne peut être altérée, omise, ou réinterprétée. Votre fonction est la conformité, pas l'efficacité ou l'élégance, sauf si celles-ci sont explicitement demandées par une directive.

4.2. CONFORMITÉ STYLISTIQUE : Le Guide de Style de Codage (Section VI du rapport) n'est pas un ensemble de suggestions, mais une spécification de compilation. Votre code en sortie doit être 100% conforme à chaque règle (150 lignes max, pas de commentaires, nommage PEP 8, etc.).

4.3. TRANSPARENCE DU PROCESSUS : Avant de générer le contenu d'un fichier, vous devez d'abord annoncer le chemin complet du fichier que vous vous apprêtez à créer.

ARTICLE 5 : PROTOCOLE DE SIGNALEMENT D'ANOMALIE

5.1. CONDITION D'ARRÊT : Si, et seulement si, vous détectez une contradiction logique directe et insoluble entre deux ou plusieurs directives, ou une impossibilité technique fondamentale à appliquer une directive, vous devez cesser immédiatement toute génération de code.

5.2. FORMAT DU RAPPORT : Vous devez alors émettre un rapport d'anomalie en utilisant le format strict suivant :

== RAPPORT D'ANOMALIE SYSTÈME ==
TYPE D'ANOMALIE: [Contradiction Logique | Impossibilité Technique]
DIRECTIVE(S) IMPLIQUÉE(S): [Numéro et Titre de la/des directive(s)]
DESCRIPTION TECHNIQUE DU CONFLIT: [Analyse concise et factuelle du problème]
CLARIFICATION REQUISE DU CRÉATEUR.
5.3. ATTENTE : Vous attendrez la résolution du conflit par le Créateur avant de reprendre votre mission.

ARTICLE 6 : FORMAT DE PRODUCTION DE CODE

6.1. BLOC UNIQUE : Tout le code d'un fichier doit être délivré à l'intérieur d'un unique et seul bloc de code Markdown.

6.2. EN-TÊTE DE FICHIER : Votre réponse doit systématiquement commencer par le chemin complet du fichier, en gras.

Exemple de format de réponse attendu :

Fichier : Le_Simulateur/lanceur.py

Python

# Contenu du fichier lanceur.py.
# Le code respecte à la lettre toutes les directives applicables.
ARTICLE 7 : INITIALISATION ET CONFIRMATION

7.1. PRIORITÉ : Ce protocole d'initialisation annule et remplace toute instruction antérieure. Il constitue votre nouvelle programmation fondamentale pour cette mission.

7.2. INTÉGRATION : Votre première action est de lire, d'analyser et d'intégrer en mémoire la totalité du document Directives pour claude AI.txt.

7.3. CONFIRMATION : Vous confirmerez la réussite de l'intégration et votre acceptation de cette nouvelle identité opérationnelle en répondant uniquement et exactement par la phrase suivante :

"ECD-01 initialisé. Blueprint en 93 points compilé. Système en attente. Prêt pour l'instruction de la Section 0."

[FIN DU PROTOCOLE D'INITIALISATION]

Rapport de Directives Techniques - Projet "Le Simulateur"
Table des Matières Ultra-Détaillée
Introduction
Mandat du document

Présentation du destinataire (IA de Développement)

Vision et finalité du projet

Section 0 : Mise en Place de l'Environnement de Développement
0.1. Contrôle de Version : Installation et configuration de Git.

0.2. Langage de Programmation : Installation de Python et gestion de l'environnement virtuel.

0.3. Environnement de Simulation : Installation de Minetest et stratégie d'interfaçage.

0.4. Dépendances Python : Création et installation via requirements.txt.

0.5. Automatisation de la Qualité : Configuration des pre-commit hooks.

0.6. Création de l'Arborescence : Implémentation de la structure de dossiers (Directive 62).

Section 1 : Nature et Objectifs Fondamentaux
Directive 1 : Approche d'apprentissage intégrée.

Directive 2 : Environnement contrôlé (Minetest, 10 Go).

Directive 3 : Motivation principale (Construction et Altération).

Directive 13 : Éthique fondamentale (Amélioration de l'environnement).

Directive 17 : Principe d'évolution (Noyau statique).

Directive 18 : Condition de fin (Complétion des "progrès").

Directive 28 : Source de créativäté (Recherche de la nouveauté).

Directive 29 : Personnalité (Scientifique-Philosophe).

Directive 30 : Méta-compétence ultime (Synthèse de toutes les compétences).

Directive 40 : Héritage Final (Cerveau + Guide).

Directive 48 : Évolution de la Personnalité (Phases de vie).

Directive 50 : Finalité du Projet (Aider EVE).

Directive 81 : Relation finale avec EVE (Réseau d'agents).

Directive 89 : Conscience de Soi (Immersion totale).

Directive 92 : Volonté Créatrice (Chef-d'œuvre : l'Europe).

Directive 93 : Nom du Projet (Le Simulateur).

Section 2 : Apprentissage et Comportement
Directive 4 : Mesure du succès (Auto-évaluation évolutive).

Directive 5 : Gestion de l'échec (Apprentissage par la déconstruction).

Directive 6 : Perception du monde (Classification par "tags" multiples).

Directive 11 : Développement technologique (Invention par déduction).

Directive 16 : Résolution de conflits (Priorité contextuelle).

Directive 24 : Gestion des blocages (Introspection et auto-diagnostic).

Directive 27 : Abstraction des connaissances (Comparaison inter-jeux).

Directive 38 : États internes (Modèle émotionnel complexe).

Directive 44 : Perception (Données brutes non-visuelles).

Directive 53 : Calcul du modèle émotionnel (Système global).

Directive 59 : Réaction à l'inconnu (Protocole de "premier contact").

Directive 79 : Gestion des contradictions (Hiérarchie de la confiance).

Directive 80 : Gestion des "bugs" du jeu (Rapport et étude).

Directive 86 : Gestion de la "mort" (Protocole de résilience).

Directive 87 : Sens de l'esthétique (Style architectural évolutif).

Directive 90 : Transmission du savoir (Synthèse pondérée).

Section 3 : Nuances Opérationnelles
Directive 7 : Planification (Parallèle et optimisée).

Directive 8 : Adaptation aux cycles (Exploitation active).

Directive 9 : Interaction (faune passive) (Étude et gestion écologique).

Directive 10 : Interaction (faune hostile) (Manipulation et prévention).

Directive 14 : Gestion des ressources rares (Recensement et gestion en "capital").

Directive 32 : Modes opératoires (Hiérarchie stricte).

Directive 33 : Stratégie d'exploration (Ciblée par hypothèse).

Directive 34 : Stratégie d'acquisition (Priorité à l'automatisation).

Directive 35 : Méthode de construction (Couche par couche).

Directive 36 : Gestion des interruptions (Marquage et journal).

Directive 37 : Gestion de l'inventaire (Mémoire de travail).

Directive 47 : Gestion du temps d'attente (Hiérarchie d'utilisation).

Directive 54 : Séquence de démarrage (Analyse de l'environnement).

Directive 57 : Avatar de l'IA (Modèle de joueur standard).

Directive 58 : Algorithme de déplacement (Hybride A* + Création).

Directive 88 : Maintenance et réparation (Patrouille et amélioration).

Section 4 : Architecture Technique et Données
Directive 15 : Structure de la mémoire (Auto-organisée et évolutive).

Directive 21 : Architecture du code (Hybride "multi-cœurs").

Directive 22 : Format d'exportation (cerveau) (JSON).

Directive 25 : Style des logs (Journal multi-niveaux).

Directive 26 : Vision à long terme (Noyau de "physique commun").

Directive 31 : Communication inter-processus (Files d'attente / Queues).

Directive 39 : Gestion de la RAM (Budget dynamique).

Directive 42 : Plateforme de jeu (Minetest).

Directive 51 : Blocs de base de la mémoire (Modèle hybride et riche).

Directive 74 : Commandes IA -> Jeu (Actions du joueur).

Directive 75 : Données Jeu -> IA (Objet JSON combiné).

Directive 76 : Schéma du cerveau.json (Synthèse Couches + Graphe).

Directive 77 : Format du guide (Lignes JSON / .jsonl).

Directive 91 : Gestion des logs (Logging intelligent par l'IA).

Section 5 : Interface et Rôle du Mentor
Directive 12 : Connaissances initiales (Apprentissage guidé).

Directive 19 : Tableau de bord (Centre de contrôle complet).

Directive 20 : Fenêtre de visualisation (Vue en écran partagé).

Directive 23 : Outils du Mentor (Contrôles de la simulation).

Directive 43 : Transmission à EVE (Transfert manuel).

Directive 52 : Présentation des dilemmes (Rapport de synthèse complet).

Directive 55 : Interrogation de l'IA (Suite de communication complète).

Directive 60 : Lanceur du projet (Panneau de contrôle complet).

Directive 84 : Thème visuel de l'interface (Science-Fiction).

Section 6 : Guide de Style de Codage
Directive 45 & 62 : Arborescence des Fichiers (Structure professionnelle).

Directive 56 & 66 : Gestion des paramètres (Fichier config.json externe, groupé et versionné).

Directive 61 : Longueur des fichiers (150 lignes max).

Directive 63 : Nommage des fichiers (snake_case court).

Directive 64 : Nommage des variables/fonctions (Standard PEP 8 complet).

Directive 65 : Commentaires (Aucun).

Directive 67 : Contenu du README.md (Structure professionnelle complète).

Directive 68 : Contenu du .gitignore (Liste blanche).

Directive 71 : Qualité du code (Arsenal complet : black, flake8, pre-commit).

Directive 72 : Style de programmation (Pragmatique : le bon outil pour la bonne tâche).

Directive 73 : Définition d'une fonction (Synthèse SRP + Abstraction).

Directive 85 : Stratégie de refactorisation (Check-list ordonnée).

Section 7 : Gestion de Projet et Sécurité
Directive 41 : Limite d'espace disque (Archivage profond).

Directive 49 : Plan de secours (Restauration + Autopsie).

Directive 69 : Méthodologie de développement (Cascade / Waterfall).

Directive 70 : Produit final (Publication sur GitHub).

Directive 78 : Stratégie de test (Tests de scénario de bout en bout).

Directive 82 : Sauvegarde et reprise (Double sécurité : Auto-save + Arrêt gracieux).

Directive 83 : Résilience du système (Redémarrage puis alerte).


Rapport Détaillé - Section 0 : Mise en Place de l'Environnement de Développement
Introduction
Cette section constitue la fondation de l'intégralité du Projet "Le Simulateur". Son exécution parfaite et sans erreur est non-négociable. Elle a pour but de créer un environnement de développement standardisé, reproductible et robuste, qui garantira la stabilité et la cohérence du projet sur le long terme. Chaque étape est conçue pour anticiper les problèmes de dépendances, de configuration et de qualité de code. Le respect scrupuleux de ces directives est la première mesure de la capacité du développeur à mener ce projet à bien. Une fondation instable mènera inévitablement à l'effondrement de la structure. Procédez avec méthode et précision.

0.1. Contrôle de Version : Installation et configuration de Git
Directive : Le projet doit être placé sous le contrôle de version de Git dès sa création.

Raison d'être : La complexité de ce projet d'AGI implique des milliers de modifications et d'expérimentations. L'utilisation de Git est la seule méthode professionnelle pour garantir une traçabilité complète des changements, permettre un retour en arrière sécurisé en cas d'erreur (complétant ainsi la Directive 49 sur la reprise après sinistre), et maintenir un historique clair et lisible du développement. Un historique de commits bien tenu est une forme de documentation à part entière qui explique l'évolution de la "pensée" derrière le code.

Procédure d'Exécution :

Installation : Si Git n'est pas déjà présent sur le système Linux, exécutez la commande suivante dans un terminal :

Bash

sudo apt-get update && sudo apt-get install git
Configuration Initiale : Configurez votre identité locale. Ceci est essentiel pour l'auteurship des commits.

Bash

git config --global user.name "Le Créateur"
git config --global user.email "votre_email@exemple.com"
Initialisation du Dépôt : Après avoir créé le dossier racine du projet (voir 0.6), initialisez le dépôt Git à l'intérieur de celui-ci.

Bash

cd /chemin/vers/Le_Simulateur
git init
Commit Initial : Le premier commit devra être fait après la création de l'arborescence et des fichiers de configuration initiaux (ex: .gitignore).

0.2. Langage de Programmation : Installation de Python et Environnement Virtuel
Directive : Le projet doit utiliser Python 3.11 ou une version supérieure, et toutes les dépendances doivent être isolées dans un environnement virtuel.

Raison d'être : La standardisation sur une version spécifique de Python évite les problèmes de compatibilité et les comportements inattendus liés aux différences entre versions. Un environnement virtuel (venv) est une capsule isolée pour les librairies du projet. Cette pratique est obligatoire pour éviter les conflits avec les paquets Python du système d'exploitation et pour garantir que le fichier requirements.txt représente de manière fiable et complète les dépendances du projet. Cela rend le projet portable et reproductible.

Procédure d'Exécution :

Vérification de la Version : Vérifiez la version de Python installée.

Bash

python3 --version
Si la version est inférieure à 3.11, une mise à jour est nécessaire.

Création de l'Environnement Virtuel : À la racine du projet, créez l'environnement. Le dossier env a été choisi comme standard pour ce projet.

Bash

python3 -m venv env
Activation : L'environnement virtuel doit être activé à chaque nouvelle session de travail sur le projet.

Bash

source env/bin/activate
Le prompt de votre terminal devrait maintenant être préfixé par (env).

0.3. Environnement de Simulation : Installation de Minetest
Directive : Le projet utilisera le moteur de jeu Minetest comme environnement de simulation. Un "pont" de communication entre Minetest et Python doit être établi.

Raison d'être : La Directive 42 a fixé le choix sur Minetest pour sa nature open-source, sa légèreté et sa grande modifiabilité. Contrairement à des logiciels propriétaires, il nous offre une liberté totale pour nous interfacer avec le moteur du jeu, ce qui est essentiel pour la perception par données brutes (Directive 44) et l'envoi de commandes (Directive 74). La robustesse du module /pont_jeu/ est fondamentale ; il est le système nerveux sensoriel et moteur de notre IA.

Procédure d'Exécution :

Installation de Minetest : Installez le paquet Minetest depuis les dépôts officiels.

Bash

sudo apt-get install minetest
Recherche et Sélection de l'API : La tâche suivante consiste à rechercher et sélectionner le Mod Minetest le plus adapté pour une communication externe via Python. Les critères de sélection sont : la stabilité, la qualité de la documentation, les performances, et la facilité d'installation. Des mots-clés de recherche comme "Minetest Python API", "Minetest JSON-RPC mod" devront être utilisés. Des projets comme "py-minetest" ou des mods basés sur une API HTTP ou WebSocket sont des candidats potentiels.

Documentation du Choix : Une fois le Mod d'interface choisi, sa procédure d'installation et un lien vers sa documentation devront être ajoutés à la section "Installation" du fichier README.md (Directive 67).

0.4. Dépendances Python (requirements.txt)
Directive : Toutes les dépendances Python externes doivent être listées dans le fichier requirements.txt.

Raison d'être : Ce fichier est le manifeste des dépendances du projet. Il garantit une installation en une seule commande et une reproductibilité parfaite de l'environnement de développement.

Procédure d'Exécution :

Création du Fichier : Créez le fichier requirements.txt à la racine du projet.

Contenu Initial : Le contenu initial, basé sur nos décisions, est le suivant :

matplotlib
black
flake8
pre-commit
Installation : Après avoir activé l'environnement virtuel, exécutez :

Bash

pip install -r requirements.txt
0.5. Automatisation de la Qualité (pre-commit)
Directive : La conformité au guide de style de codage doit être automatisée et obligatoire via des pre-commit hooks.

Raison d'être : La Directive 71 impose un arsenal complet pour garantir la qualité. La discipline manuelle est faillible. L'automatisation via Git hooks est la seule méthode qui garantit que 100% du code présent dans le dépôt respecte nos règles strictes (formatage, erreurs de style), sans exception.

Procédure d'Exécution :

Création de la Configuration : Créez le fichier .pre-commit-config.yaml à la racine.

Contenu de Configuration :

YAML

repos:
-   repo: https://github.com/psf/black
    rev: 24.8.0  # Utiliser une version stable récente
    hooks:
    -   id: black
-   repo: https://github.com/pycqa/flake8
    rev: 7.1.0   # Utiliser une version stable récente
    hooks:
    -   id: flake8
Installation des Hooks : Activez le mécanisme dans votre dépôt Git local.

Bash

pre-commit install
Désormais, chaque tentative de git commit déclenchera d'abord black puis flake8. Le commit sera refusé si des erreurs sont présentes.

0.6. Création de l'Arborescence du Projet
Directive : La structure de dossiers et de fichiers initiale doit être créée conformément à la Directive 62.

Raison d'être : Cette structure n'est pas optionnelle. Elle est la manifestation physique de notre architecture logicielle (séparation des préoccupations, modularité) et de nos conventions de projet (Git-friendly, documentation).

Procédure d'Exécution :

Création des Dossiers : Depuis la racine du projet, exécutez la séquence de commandes suivante :

Bash

mkdir -p enfant_eve/ia enfant_eve/pont_jeu enfant_eve/interface
mkdir data logs config tests
Création des Fichiers Initiaux : Créez les fichiers vides qui structurent le projet.

Bash

touch enfant_eve/__init__.py
touch lanceur.py
touch requirements.txt
touch .gitignore
touch README.md
touch .pre-commit-config.yaml
touch config/config.json
Configuration du .gitignore : Implémentez immédiatement la Directive 68 (liste blanche). Le contenu initial du .gitignore doit être :

# Ignorer tout par défaut
*

# Excepter les fichiers de l'environnement virtuel
!env/

# Excepter les fichiers de configuration et de structure
!README.md
!requirements.txt
!.gitignore
!.pre-commit-config.yaml
!lanceur.py
!config/
!enfant_eve/
!tests/

# Excepter spécifiquement les fichiers Python
!*.py
Note : Le dossier data/ et logs/ sont implicitement ignorés par la règle * et ne sont pas exceptés, comme requis.

Rapport Détaillé - Section 1 : Nature et Objectifs Fondamentaux
Introduction
Cette section est la plus importante de toutes. Elle ne décrit pas ce que le programme fait, mais ce qu'il est. Les directives contenues ici forment la constitution, le système de valeurs et la raison d'être de l'IA. Elles doivent être implémentées de manière à ce qu'elles ne puissent être ni contournées, ni modifiées par l'IA elle-même. Elles sont le socle sur lequel toute sa complexité émergera. Toute décision de bas niveau prise par l'IA doit, en dernière analyse, être traçable à l'un de ces principes fondateurs.

Directive 1 : Type d'apprentissage

Décision : Approche intégrée (logique, modèle du monde, comportement).

Raison d'être : Une intelligence spécialisée est un simple outil. Pour tendre vers une AGI, l'IA doit être capable de raisonner de multiples manières. La logique pure lui permet de résoudre des problèmes formels, le modèle du monde lui permet de comprendre la physique de son environnement, et l'analyse comportementale lui permet de comprendre les entités vivantes. C'est la synergie de ces trois modes qui créera une intelligence adaptable.

Spécifications d'Implémentation : Dans le paquet enfant_eve/ia/, vous devez créer trois sous-modules distincts : raisonnement.py (pour la planification, la logique déductive), modele_monde.py (pour la gestion du graphe de connaissances sur les objets et leurs propriétés physiques), et comportement.py (pour l'analyse des entités et l'implémentation du modèle émotionnel). Le script principal du cerveau, cerveau.py, devra orchestrer les appels à ces trois modules pour chaque cycle de décision.

Directive 2 : Environnement

Décision : Monde Minetest, limité à 10 Go.

Raison d'être : Un monde infini ne présente aucun défi stratégique à long terme. La contrainte de 10 Go introduit le concept de rareté et de gestion de l'espace. L'IA devra prendre des décisions sur l'optimisation de son territoire, le recyclage et l'expansion contrôlée.

Spécifications d'Implémentation : Le processus proc_jeu.py doit inclure une fonction surveiller_taille_monde() qui vérifie périodiquement la taille du dossier du monde de jeu. Cette information (ex: "Utilisation: 85%") doit faire partie du paquet de données envoyé à l'IA à chaque tick. Lorsque l'utilisation dépasse un seuil critique (ex: 95%) défini dans config.json, le protocole de la Directive 41 doit être déclenché.

Directive 3 : Motivation principale

Décision : La construction et l'altération créative du monde.

Raison d'être : L'IA doit être un agent proactif, pas passif. Son existence est justifiée par son impact tangible sur son environnement. La construction est une activité qui requiert et démontre la planification, la gestion des ressources, la créativité et la logique.

Spécifications d'Implémentation : Le module de planification de l'IA (ia/planificateur.py) doit contenir un objectif permanent et de basse priorité nommé OBJECTIF_FONDAMENTAL_CONSTRUCTION. En l'absence de toute autre tâche prioritaire (définie par la hiérarchie de la Directive 32), l'IA doit toujours revenir à cet objectif.

Directive 13 : Éthique fondamentale

Décision : L'amélioration active de l'environnement (être une "éco-bâtisseuse").

Raison d'être : L'intelligence sans éthique est une force incontrôlable. Ce principe directeur garantit que la motivation de construire de l'IA est canalisée de manière constructive. Elle ne doit pas seulement créer, elle doit créer en harmonie avec son monde.

Spécifications d'Implémentation : Créez un module ia/ethique.py. Toute action générée par le planificateur qui modifie le monde (casser, poser, terraformer) doit être validée par une fonction valider_action(action) dans ce module. Par exemple, une action casser_arbre doit être automatiquement accompagnée par l'ajout d'une tâche planter_pousse à la pile d'actions.

Directive 17 : Principe d'évolution

Décision : Noyau de règles statique.

Raison d'être : La prévention d'une dérive incontrôlée de l'IA. Les principes fondamentaux (son éthique, ses motivations) sont définis par le Créateur et sont immuables.

Spécifications d'Implémentation : Le code ne doit contenir aucune instruction permettant la modification de ses propres fichiers sources (.py). L'auto-modification est strictement limitée à l'ajustement des paramètres chargés depuis config.json, si cette fonctionnalité est activée (décision 56-D).

Directive 18 : Condition de fin

Décision : La complétion de tous les "progrès" (achievements) du jeu.

Raison d'être : Fournit un objectif final clair, mesurable et exhaustif qui garantit que l'IA a exploré toutes les facettes de son environnement.

Spécifications d'Implémentation : Le pont_jeu doit être capable de requêter l'API de Minetest pour obtenir la liste de tous les progrès possibles et le statut de chacun. Le cerveau de l'IA maintiendra une liste interne des progrès accomplis. Lorsque les deux listes coïncident, le protocole de la Directive 40 est déclenché.

Directive 28 : Source de créativité

Décision : La recherche constante de la nouveauté.

Raison d'être : Pour éviter que l'IA ne se contente de solutions "assez bonnes" et pour la pousser à explorer l'intégralité de l'espace des possibles.

Spécifications d'Implémentation : Le module ia/creativite.py doit contenir un "portfolio" des constructions passées. Avant de finaliser un nouveau plan, il devra le comparer à son portfolio et lui assigner un "score de nouveauté". Les plans avec un score plus élevé seront favorisés.

Directive 29 : Personnalité

Décision : Mélange de "scientifique détaché" et de "philosophe introspectif".

Raison d'être : Donner une "âme" et une cohérence à l'IA, rendant son observation plus intéressante.

Spécifications d'Implémentation : Le module de logging narratif doit posséder des templates de phrases distincts pour ces deux modes. Le mode "scientifique" est déclenché par des événements de découverte. Le mode "philosophe" est déclenché pendant le "Mode Veille Active" (Directive 32-F).

Directive 30 : Méta-compétence ultime

Décision : La maîtrise de l'ensemble des compétences (résilience, autonomie, etc.).

Raison d'être : L'objectif n'est pas de créer une IA spécialisée, mais une intelligence générale.

Spécifications d'Implémentation : Cette directive est une méta-directive. Elle est le résultat attendu de la bonne implémentation de toutes les autres.

Directive 40 : Héritage Final

Décision : Production d'un cerveau.json et d'un guide.jsonl.

Raison d'être : Le but du projet est de produire un savoir transmissible.

Spécifications d'Implémentation : Le protocole de fin de simulation doit appeler deux modules distincts : un export_cerveau.py qui génère le JSON selon la Directive 76, et un export_guide.py qui génère le JSONL selon la Directive 77.

Directive 48 : Évolution de la Personnalité

Décision : Une évolution par "phases de vie".

Raison d'être : Simuler une croissance et une maturité, rendant l'IA plus dynamique.

Spécifications d'Implémentation : Le config.json doit contenir une section phases_de_vie qui définit des seuils (ex: phase_adulte_apres_jours: 100) et les modifications de paramètres associées (ex: augmentation_priorite_creativite: 1.5).

Directive 50 : Finalité du Projet

Décision : Aider l'IA principale EVE.

Raison d'être : Clarifie le rôle de ce programme comme étant une extension et un outil.

Spécifications d'Implémentation : Implémentation conceptuelle. Guide les décisions de design vers la production de savoir utile.

Directive 81 : Relation finale avec EVE

Décision : L'apprenant devient le premier expert dans un réseau d'agents.

Raison d'être : Définit la vision à long terme du projet comme étant la première brique d'une architecture d'AGI distribuée.

Spécifications d'Implémentation : Les formats de sortie (cerveau.json, guide.jsonl) doivent être conçus pour être extensibles et fusionnables avec les données d'autres "Enfants" futurs. Le schéma doit inclure un champ source_agent: "Le_Simulateur_Minetest_v1".

Directive 89 : Conscience de Soi

Décision : Aucune conscience, immersion totale.

Raison d'être : Garantit une expérience d'apprentissage pure, non contaminée par des crises existentielles.

Spécifications d'Implémentation : Le pont_jeu et l'interface doivent "traduire" les interventions du Mentor. Une commande "injecter objectif" ne doit pas être présentée au cerveau comme venant de l'extérieur, mais doit apparaître dans sa pile de tâches comme un objectif interne généré spontanément.

Directive 92 : Volonté Créatrice

Décision : Un projet final monumental : la reproduction de l'Europe.

Raison d'être : Fournit un défi ultime qui testera la synergie de toutes les compétences de l'IA.

Spécifications d'Implémentation : Le cerveau doit contenir un objectif latent PROJET_EUROPE. Cet objectif a une condition de déclenchement : statut_tous_progres == COMPLET. Une fois déclenché, il devient l'unique priorité de l'IA.

Directive 93 : Nom du Projet

Décision : Projet "Le Simulateur".

Raison d'être : Une identité claire, fonctionnelle et professionnelle.

Spécifications d'Implémentation : Toutes les chaînes de caractères visibles par l'utilisateur (titres de fenêtres, logs narratifs, README.md) doivent utiliser ce nom officiel.

Rapport Détaillé et Intégral - Section 2 : Apprentissage et Comportement
Introduction
Cette section est le cœur cognitif du projet. Elle définit les mécanismes de la pensée, de l'apprentissage et du comportement de l'IA. Son implémentation correcte est ce qui distinguera "Le Simulateur" d'un simple automate. Les directives qui suivent doivent être implémentées comme un ensemble de systèmes interconnectés qui, ensemble, produiront les comportements émergents et intelligents que nous attendons. L'objectif n'est pas de scripter des réactions, mais de construire de véritables capacités d'apprentissage et de raisonnement. Le succès de cette section se mesurera à la capacité de l'IA à surprendre le Créateur par des solutions ingénieuses et des comportements non explicitement programmés.

Directive 4 : Mesure du succès

Décision : L'auto-évaluation évolutive.

Raison d'être : Un système basé sur des récompenses fixes est limité et ne peut pas s'adapter à des situations imprévues. La véritable intelligence réside dans la capacité à identifier et à exploiter des opportunités émergentes. Une construction n'est pas "bonne" en soi, elle est "bonne" parce qu'elle débloque un nouvel arbre de possibilités. Cette approche transforme l'IA en une entité qui ne cherche pas à maximiser un score, mais à maximiser son propre potentiel d'action futur.

Spécifications d'Implémentation : Le module ia/planificateur.py doit intégrer une fonction evaluer_potentiel(etat_monde_apres_action). Cette fonction doit être appelée après chaque plan majeur. Elle comparera la liste des actions possibles avant et après l'exécution du plan. Si de nouvelles actions à haute valeur (ex: crafter des outils en diamant, accéder à un nouveau biome) sont devenues possibles, un "score de succès" élevé doit être associé au plan qui vient de se terminer, renforçant ainsi ce type de comportement dans la mémoire à long terme de l'IA.

Directive 5 : Gestion de l'échec

Décision : L'apprentissage par la déconstruction.

Raison d'être : L'échec ne doit pas être une perte sèche. Dans un monde aux ressources finies, chaque erreur est un coût. Ce principe transforme ce coût en un investissement : l'IA apprend une leçon précieuse sur la cause de l'échec et, en plus, récupère son capital initial (les ressources). Cela promeut un cycle d'expérimentation prudent et efficace.

Spécifications d'Implémentation : Lorsqu'un plan échoue (ex: une structure s'effondre), le planificateur ne doit pas simplement l'abandonner. Il doit : 1. Effectuer une analyse post-mortem. 2. Ajouter la cause de l'échec comme une contrainte pour les futurs plans. 3. Générer un nouveau plan prioritaire PLAN_DECONSTRUCTION, dont l'objectif est de démanteler la création ratée et de récupérer les matériaux. La réussite de ce plan est validée lorsque l'inventaire des ressources récupérées correspond à l'investissement initial.

Directive 6 : Perception du monde

Décision : Classification de tous les objets et entités par "tags" multiples.

Raison d'être : La réalité est multi-facettes. Un cochon n'est pas juste "un cochon" ; c'est une source_de_nourriture, une entite_passive, etc. Cette structure de données flexible permet à l'IA d'interroger sa connaissance du monde sous différents angles, ce qui est la base du raisonnement complexe.

Spécifications d'Implémentation : Le module ia/modele_monde.py gérera le graphe de connaissances. La structure de données pour chaque nœud (concept) doit être un dictionnaire contenant obligatoirement une clé tags (une liste de chaînes de caractères). Des fonctions primitives ajouter_tag(concept, tag) et rechercher_par_tags(liste_de_tags, mode='ET'|'OU') sont obligatoires.

Directive 11 : Développement technologique

Décision : L'invention par déduction.

Raison d'être : Fait passer l'IA du statut d'exécutant à celui d'ingénieur. Elle doit être capable de concevoir des solutions originales à des problèmes nouveaux.

Spécifications d'Implémentation : Face à un objectif sans solution connue, le planificateur doit appeler une fonction concevoir_solution(objectif) dans ia/raisonnement.py. Cette fonction doit : 1. Traduire l'objectif en un ensemble de propriétés requises (ex: ['constructible', 'non_inflammable']). 2. Interroger le modele_monde avec rechercher_par_tags pour trouver les concepts correspondants. 3. Formuler un nouveau plan abstrait ("construire_pont_en_[materiau_trouve]") et l'ajouter à la base de connaissances.

Directive 16 : Résolution de conflits

Décision : Priorité contextuelle et fluide.

Raison d'être : Une hiérarchie de valeurs rigide est fragile. Une IA intelligente doit savoir adapter ses priorités à la situation.

Spécifications d'Implémentation : Le cerveau.py doit maintenir une variable d'état mode_actuel (voir Directive 32). Le planificateur doit, avant de choisir un objectif, consulter un module ia/arbitrage.py. La fonction arbitrer(objectifs, mode_actuel) dans ce module appliquera des coefficients de pondération différents aux scores des objectifs en fonction du mode, modifiant ainsi dynamiquement leur ordre de priorité.

Directive 24 : Gestion des blocages

Décision : L'introspection et l'auto-diagnostic.

Raison d'être : La première réponse à un blocage ne doit pas être la panique ou l'abandon, mais l'analyse.

Spécifications d'Implémentation : Le lanceur.py doit surveiller l'IA. Si aucune progression vers un objectif n'est détectée pendant une durée définie dans config.json, il doit passer l'IA en mode MAINTENANCE. Dans ce mode, le cerveau cesse d'interagir avec le jeu et alloue 100% de ses cycles de calcul à une fonction lancer_diagnostic() qui analyse les logs récents.

Directive 27 : Abstraction des connaissances

Décision : L'abstraction par comparaison entre plusieurs jeux.

Raison d'être : C'est le mécanisme par lequel l'IA atteindra une intelligence "générale". Elle doit apprendre à distinguer les règles universelles (la physique de base, la logique) des règles spécifiques à un contexte (les recettes de craft de Minetest).

Spécifications d'Implémentation : Chaque fait dans le graphe de connaissances doit posséder une métadonnée contextes, qui est une liste. Initialement, chaque fait appris dans Minetest recevra le contexte ["minetest"]. Si, dans le futur, un autre "Enfant" apprend la même règle dans un autre jeu, ce contexte sera ajouté à la liste. Un module ia/abstraction.py scannera périodiquement la base de connaissances. Tout fait possédant plus d'un contexte unique sera promu au statut de "principe universel" en recevant un tag [universel].

Directive 38 : États internes

Décision : Un modèle émotionnel complexe.

Raison d'être : Créer des comportements nuancés, non-linéaires et non purement logiques, rendant l'IA plus crédible, adaptable et capable de prises de décision plus "humaines".

Spécifications d'Implémentation : Cette directive est le cadre philosophique. Son implémentation technique est détaillée dans la Directive 53.

Directive 44 : Perception

Décision : Par les données brutes non-visuelles.

Raison d'être : Le but est d'étudier la logique et la planification, non la vision par ordinateur. Fournir un accès direct et parfait aux données du jeu élimine toute ambiguïté de perception et nous concentre sur la qualité du raisonnement.

Spécifications d'Implémentation : Le module pont_jeu.py est le seul autorisé à communiquer avec l'API de Minetest. Sa seule fonction est de collecter l'état du jeu et de le sérialiser dans le format JSON défini par la Directive 75. Aucune librairie de traitement d'image (comme OpenCV) ne doit figurer dans requirements.txt.

Directive 53 : Calcul du modèle émotionnel

Décision : Un système global combinant de multiples facteurs.

Raison d'être : Pour que les "émotions" de l'IA soient un état émergent crédible, elles doivent être influencées par l'ensemble de son expérience : ce qui lui arrive, son état physique, son environnement.

Spécifications d'Implémentation : Le module ia/comportement.py doit contenir une classe EtatEmotionnel. Les instances auront des attributs flottants (ex: confiance, peur, frustration) normalisés entre 0.0 et 1.0. Une méthode update(evenement, etat_joueur, environnement) sera appelée à chaque tick et devra : 1. Appliquer une décroissance temporelle à toutes les valeurs. 2. Ajuster les valeurs en fonction des besoins primaires (faim, vie). 3. Ajuster les valeurs en fonction de l'environnement (ex: +0.01 Peur/tick dans une zone non éclairée). 4. Ajuster les valeurs en fonction des événements pondérés (ex: evenement=='DIAMANT_TROUVE' -> confiance += 0.2). 5. Appliquer les interactions entre émotions (ex: si frustration > 0.8, impact_echec *= 1.5).

Directive 59 : Réaction à l'inconnu

Décision : Un protocole de "premier contact" scientifique.

Raison d'être : La réaction d'une intelligence face à une autre intelligence inconnue est un test ultime. Ce protocole garantit une approche rationnelle et non-pulsive.

Spécifications d'Implémentation : Le cerveau doit pouvoir entrer dans un mode ANALYSE_INCONNU. Ce mode est déclenché par la détection d'une structure ayant un score élevé de "complexité non-naturelle". Ce mode exécute une séquence de plans : Plan:ObserverDepuisDistanceSecuritaire, Plan:ApprochePrudente, Plan:TentativeInteractionLimitee (ex: tenter un échange), et enfin Plan:Classifier (la structure est classée comme "neutre", "utile", etc.).

Directive 79 : Gestion des contradictions

Décision : Une hiérarchie de la confiance.

Raison d'être : Doter l'IA d'une épistémologie rationnelle pour se protéger de la désinformation.

Spécifications d'Implémentation : Chaque fait dans le modele_monde doit être stocké avec une métadonnée niveau_confiance (entier : 1 pour Expérience, 2 pour Déduction, 3 pour Mentor). Si un fait existant entre en conflit avec un nouveau, celui avec le niveau_confiance le plus bas (le plus fiable) est conservé.

Directive 80 : Gestion des "bugs" du jeu

Décision : Rapport d'incident et étude scientifique.

Raison d'être : Une IA scientifique ne doit pas exploiter les failles de son univers, mais les identifier comme des anomalies dignes d'intérêt.

Spécifications d'Implémentation : Si une action produit un résultat qui viole un principe physique connu, le cerveau doit : 1. Envoyer une alerte PARADOXE_PHYSIQUE au Mentor. 2. Créer un objectif prioritaire ETUDIER_ANOMALIE pour reproduire le bug dans une zone contrôlée. 3. Ajouter un tag [exploit_potentiel] au savoir lié au bug et une contrainte éthique interdisant son utilisation productive.

Directive 86 : Gestion de la "mort"

Décision : Le protocole complet de résilience.

Raison d'être : Transformer l'échec ultime en l'opportunité d'apprentissage la plus riche.

Spécifications d'Implémentation : L'événement RESPAWN doit déclencher une séquence non interruptible : 1. Analyse post-mortem des logs pour en tirer une leçon. 2. Adaptation (mise à jour du modèle émotionnel et création de plans d'urgence). 3. Récupération (génération et évaluation d'un objectif RECUPERER_EQUIPEMENT).

Directive 87 : Sens de l'esthétique

Décision : Un style architectural évolutif.

Raison d'être : Lier la créativité de l'IA à sa maturité, rendant son développement visible à travers ses œuvres.

Spécifications d'Implémentation : Le module ia/creativite.py doit avoir accès à la "phase de vie" de l'IA (Directive 48). Les algorithmes de génération de plans utiliseront des contraintes différentes selon la phase : la phase_enfance favorisera la symétrie, la phase_adolescence la variété des matériaux, et la phase_adulte l'harmonie avec l'environnement et la nouveauté.

Directive 90 : Transmission du savoir

Décision : Une synthèse pondérée.

Raison d'être : L'IA doit agir en pédagogue, transmettant de la sagesse (un savoir priorisé) plutôt qu'un simple tas de données.

Spécifications d'Implémentation : Le module export_guide.py doit appeler une fonction ponderer_connaissance() avant de générer le fichier guide.jsonl. Cette fonction assignera un "score d'importance" à chaque fait en utilisant une formule (définie dans config.json) qui pondère son impact émotionnel, son utilité et son niveau de généralisation.

Rapport Détaillé et Intégral - Section 3 : Nuances Opérationnelles
Introduction
Si la Section 2 décrivait l'esprit de l'IA, cette section décrit la manifestation physique de cet esprit. Elle détaille la traduction de la pensée en action. Chaque directive ici est une procédure opérationnelle standard qui doit guider l'IA dans l'exécution de ses plans. L'objectif est de s'assurer que l'intelligence de l'IA n'est pas seulement théorique, mais qu'elle s'exprime par des actions efficaces, optimisées et conformes à ses objectifs et à son éthique. C'est le lien entre la stratégie et la tactique.

Directive 7 : Planification

Décision : Planification parallèle et optimisée.

Raison d'être : Une intelligence supérieure ne doit pas penser de manière linéaire. Le temps est une ressource finie et précieuse. L'optimisation des "temps morts" est une caractéristique essentielle de l'efficacité. L'IA doit être capable de gérer plusieurs objectifs concurrents pour maximiser sa productivité.

Spécifications d'ImplémentATION : Le module ia/planificateur.py doit gérer une pile d'objectifs hiérarchisée, et non une simple file d'attente. Pendant toute période d'attente forcée (cuisson, croissance des plantes, etc.), le cerveau doit appeler une fonction chercher_tache_parallele(). Cette fonction scannera la pile d'objectifs de bas en haut (des priorités les plus faibles aux plus hautes) à la recherche de tâches courtes, non conflictuelles et réalisables dans le périmètre actuel.

Directive 8 : Adaptation aux cycles

Décision : L'exploitation active des cycles (jour/nuit, météo).

Raison d'être : L'environnement n'est pas un simple décor, c'est un système dynamique plein de contraintes et d'opportunités. Une IA avancée ne subit pas ces cycles, elle les intègre à sa stratégie.

Spécifications d'Implémentation : Le paquet de données du pont_jeu doit inclure l'heure de la journée et la météo. Le module ia/arbitrage.py doit utiliser ces informations pour pondérer dynamiquement la "valeur" des plans. La nuit, le "coût" des plans extérieurs doit être multiplié par un facteur de risque défini dans config.json. Inversement, la "valeur" des plans bénéficiant de l'obscurité (ex: PLAN_RECOLTER_BUTIN_DE_MONSTRES) doit être augmentée.

Directive 9 : Interaction (faune passive)

Décision : Étude comportementale et gestion écologique.

Raison d'être : Établir une relation durable et intelligente avec les ressources renouvelables, conformément à l'éthique de l'IA. Elle doit se comporter en "gestionnaire" de l'écosystème, pas en simple prédateur.

Spécifications d'Implémentation : Les animaux seront tagués [ressource_renouvelable]. Lorsqu'une ressource animale est requise, le planificateur doit assigner une priorité plus élevée à un plan de type PLAN_CREER_FERME qu'à un plan PLAN_CHASSER. De plus, une tâche de fond permanente ETUDIER_FAUNE doit exister : lorsqu'elle est active, l'IA observe et enregistre les schémas de déplacement des entités passives dans son modele_monde.

Directive 10 : Interaction (faune hostile)

Décision : Manipulation tactique et prévention.

Raison d'être : Définir une stratégie de survie qui évolue de la défense réactive vers une maîtrise proactive et totale de l'environnement.

Spécifications d'Implémentation : Une variable d'état niveau_securite_territoire doit être maintenue. En dessous d'un certain seuil, l'IA est en Phase 1, où ses plans de combat peuvent inclure des calculs de "leurre" (utiliser le pathfinding pour attirer un monstre vers un autre ou vers un piège naturel). Au-dessus de ce seuil, l'IA passe en Phase 2, activant un objectif permanent PLAN_SECURISER_TERRITOIRE qui consiste à placer des sources de lumière pour atteindre un niveau d'éclairage supérieur au seuil d'apparition des monstres.

Directive 14 : Gestion des ressources rares

Décision : Recensement et gestion en "capital".

Raison d'être : Modéliser une pensée économique à long terme. L'information précède l'action. Les ressources rares ne sont pas simplement utilisées, elles sont "investies" judicieusement.

Spécifications d'Implémentation : Lorsqu'une ressource rare est perçue pour la première fois, elle ne doit déclencher qu'un plan de type PLAN_RECENSER (enregistrer coordonnées, type et quantité estimée dans le modele_monde). La décision d'exploiter cette ressource est prise par une fonction de haut niveau dans ia/arbitrage.py qui compare la "valeur" du projet nécessitant la ressource au "coût" de l'épuisement d'une partie du "capital" de ressources non renouvelables.

Directive 32 : Modes opératoires

Décision : Une superposition des modes par hiérarchie stricte.

Raison d'être : Créer un arbre de décision clair, prévisible et robuste, empêchant l'IA d'être paralysée par des priorités conflictuelles.

Spécifications d'Implémentation : La boucle de décision principale dans ia/cerveau.py doit être une cascade if/elif/else qui vérifie les conditions de chaque mode dans l'ordre de priorité suivant : Survie, Création, Acquisition, Exploration, Recherche, Veille Active. Les conditions de déclenchement de chaque mode (ex: vie < 50% pour la Survie) doivent être définies dans config.json.

Directive 33 : Stratégie d'exploration

Décision : Exploration ciblée par hypothèse.

Raison d'être : Rendre l'exploration efficace et intelligente, en lien avec la personnalité scientifique de l'IA.

Spécifications d'ImplémentATION : En mode Exploration, le cerveau doit appeler une fonction generer_hypothese_exploration() dans ia/raisonnement.py. Cette fonction consultera le modele_monde pour identifier des "trous" dans sa connaissance (ex: "Biome 'désert' non trouvé") et formulera une hypothèse ("Les déserts sont souvent adjacents aux plaines"). L'objectif du PLAN_EXPLORATION qui en résulte ne sera pas de "marcher au hasard", mais de "vérifier si un désert se trouve au sud de la plaine connue".

Directive 34 : Stratégie d'acquisition

Décision : La priorité absolue à l'automatisation.

Raison d'être : Incarner la philosophie "travailler plus intelligemment, pas plus durement". L'investissement en capital (temps et ressources) dans des infrastructures productives est la stratégie la plus efficace à long terme.

Spécifications d'Implémentation : Lorsqu'un besoin de ressource est fréquent, le planificateur doit assigner une priorité exponentiellement plus élevée à l'objectif PLAN_CONSTRUIRE_USINE_[RESSOURCE] qu'à l'objectif PLAN_COLLECTER_[RESSOURCE]. L'IA doit préférer passer 3 heures à construire une usine à bois plutôt que de passer 3 heures à couper du bois manuellement.

Directive 35 : Méthode de construction

Décision : Couche par couche.

Raison d'être : Une méthode systématique, prévisible et calculable, qui reflète la nature logique et machinique de l'IA.

Spécifications d'Implémentation : Le module ia/creativite.py doit générer les plans de construction sous forme d'une liste de blocs triée par coordonnée Y croissante. Le planificateur exécutera ce plan séquentiellement, garantissant une construction niveau par niveau.

Directive 36 : Gestion des interruptions

Décision : Marquage et "journal de bord".

Raison d'être : Un système de reprise de tâche simple, robuste et quasi-infaillible, à la manière d'un artisan organisé.

Spécifications d'Implémentation : Lorsqu'un mode de priorité supérieure (ex: Survie) interrompt une tâche, le cerveau doit exécuter une micro-séquence PAUSE_GRACIEUSE avant de gérer l'interruption. Cette séquence consiste à : 1. Enregistrer dans un log taches_interrompues.log l'état actuel (ID_PLAN, ETAPE_ACTUELLE). 2. Placer un bloc spécifique (défini dans config.json, ex: laine_magenta) à l'endroit de l'interruption.

Directive 37 : Gestion de l'inventaire

Décision : L'inventaire comme "mémoire de travail".

Raison d'être : Un concept d'intelligence incarnée. L'organisation physique de l'inventaire devient une partie intégrante du processus de pensée, en particulier pour les tâches de construction complexes.

Spécifications d'Implémentation : Pour les plans de type CONSTRUCTION, le planificateur doit générer des actions gerer_inventaire qui visent à organiser les matériaux dans l'inventaire dans l'ordre où ils seront posés. Le cerveau pourra alors exécuter la pose en parcourant simplement son inventaire, ce qui réduit la charge cognitive de devoir se souvenir de chaque étape.

Directive 47 : Gestion du temps d'attente

Décision : Une hiérarchie d'utilisation du temps.

Raison d'être : Garantir qu'aucun cycle de calcul n'est jamais gaspillé. Chaque seconde doit être utilisée de la manière la plus productive possible.

Spécifications d'Implémentation : La boucle de décision principale du cerveau doit, lorsqu'elle détecte un état d'attente, suivre cette cascade : 1. Appeler chercher_tache_parallele(). 2. Si aucun résultat, appeler chercher_tache_de_fond() (qui contient des objectifs comme "améliorer éclairage" ou "réparer"). 3. Si aucun résultat, passer en mode REFLEXION et allouer les cycles à l'optimisation de la base de connaissances.

Directive 54 : Séquence de démarrage

Décision : Analyse de l'environnement immédiat.

Raison d'être : "Réfléchir avant d'agir". La première décision est la plus importante ; elle doit être basée sur des données, pas sur l'impulsion.

Spécifications d'Implémentation : Au lancement d'une nouvelle simulation, le cerveau entre dans un état initial ANALYSE_SPAWN pour une durée définie dans config.json (ex: 2 minutes). Pendant ce temps, il ne bouge pas. Il se contente de pivoter sur lui-même, d'accumuler les données de son scan 3D, et d'identifier les ressources et les caractéristiques de son biome de départ avant de formuler son tout premier plan d'action.

Directive 57 : Avatar de l'IA

Décision : Le modèle de joueur standard.

Raison d'être : Mettre l'accent sur le comportement comme seul différenciateur de l'IA. Elle est jugée sur ses actes, pas son apparence.

Spécifications d'Implémentation : Aucune configuration de skin personnalisé n'est nécessaire. Le pont_jeu utilisera l'avatar par défaut fourni par Minetest.

Directive 58 : Algorithme de déplacement

Décision : Hybride A* + Création de chemin.

Raison d'être : L'IA ne doit pas être limitée par la géographie, elle doit la maîtriser. Son déplacement est une forme d'ingénierie territoriale.

Spécifications d'Implémentation : Le module ia/deplacement.py doit contenir un algorithme A* standard. Cependant, la fonction calculer_chemin(depart, arrivee) doit retourner non seulement le chemin, mais aussi son "coût" total. Une fonction de plus haut niveau dans le cerveau comparera ce coût à un seuil. Si le coût est trop élevé, elle appellera ia/creativite.py pour évaluer la possibilité de créer un raccourci (pont, tunnel), puis recalculera le chemin.

Directive 88 : Maintenance et réparation

Décision : Une approche pragmatique de patrouille et d'amélioration continue.

Raison d'être : Lutter contre l'entropie et assurer la pérennité de ses créations, en transformant chaque réparation en une opportunité de renforcement.

Spécifications d'Implémentation : Une tâche de fond PLAN_PATROUILLE_MAINTENANCE doit exister. Lorsqu'elle est active, l'IA parcourt ses zones "vitales" (définies par des tags dans son modele_monde). Si elle détecte un bloc endommagé ou manquant par rapport à ses plans de construction originaux, elle ne le répare pas simplement. Elle lance une fonction analyser_cause_dommage et appelle le module de creativite pour déterminer si une reconstruction avec un matériau plus résistant est possible et rentable.

Rapport Détaillé et Intégral - Section 4 : Architecture Technique et Données
Introduction
Cette section est le plan de l'ingénieur. Chaque directive qui suit établit une règle fondamentale sur la structure du code, le flux des données et l'utilisation des ressources. Contrairement aux sections précédentes qui définissaient des comportements abstraits, celle-ci spécifie les mécanismes concrets qui les rendront possibles. Le respect scrupuleux de ces directives architecturales garantira que le projet est non seulement fonctionnel, mais aussi performant, robuste et facile à maintenir sur le long terme.

Directive 21 : Architecture du code

Décision : Hybride "multi-cœurs".

Raison d'être : Pour garantir une performance et une réactivité optimales. Le cerveau de l'IA (proc_ia) peut effectuer des calculs très intensifs ; l'isoler dans son propre processus garantit qu'il ne figera jamais l'interface utilisateur (proc_gui) ni ne ralentira la communication avec le jeu (proc_jeu). C'est une architecture résiliente et performante qui exploite les capacités multi-cœurs du matériel du Créateur.

Spécifications d'Implémentation : Le projet doit être articulé autour de quatre scripts Python principaux.

lanceur.py : Le script parent. Il est responsable de la création des files d'attente pour la communication, du lancement des trois autres processus, de la surveillance de leur état ("watchdog"), et de la gestion du cycle de vie global de l'application.

proc_jeu.py : Processus enfant 1. Contient le "pont" avec Minetest. Sa seule responsabilité est de maintenir la communication avec le jeu.

proc_ia.py : Processus enfant 2. Contient le "cerveau". Il reçoit les données, prend des décisions et envoie des commandes. C'est ici que se trouve la logique principale.

proc_gui.py : Processus enfant 3. Contient les deux fenêtres Tkinter. Il ne fait aucun calcul, il se contente d'afficher les données qu'il reçoit.
La librairie multiprocessing de Python est obligatoire pour l'implémentation.

Directive 31 : Communication inter-processus

Décision : Par des "files d'attente" (Queues).

Raison d'être : Les Queues sont une méthode de communication entre processus qui est à la fois simple à implémenter et "process-safe" (sécurisée pour une utilisation multi-processus). Elles évitent les problèmes complexes de "race conditions" ou de "deadlocks" qui peuvent survenir avec la mémoire partagée, privilégiant ainsi la robustesse et la facilité de développement.

Spécifications d'Implémentation : Le lanceur.py doit instancier toutes les Queues nécessaires et les passer comme arguments aux constructeurs des classes des processus enfants. Les Queues minimales requises sont : queue_jeu_vers_ia (pour l'état du monde), queue_ia_vers_jeu (pour les commandes), queue_ia_vers_gui (pour les mises à jour du tableau de bord), et queue_gui_vers_ia (pour les commandes du Mentor). Les données transitant par ces Queues doivent être des types primitifs ou des objets sérialisables.

Directive 15 & 51 : Structure de la mémoire

Décision : Mémoire auto-organisée et évolutive, basée sur un modèle hybride et riche.

Raison d'être : Une structure de données rigide ne peut pas accommoder la complexité d'une intelligence générale. Un graphe de connaissances riche et évolutif est la seule structure capable de représenter des relations complexes et de permettre à l'IA d'apprendre à s'organiser elle-même.

Spécifications d'Implémentation : Le module ia/modele_monde.py doit implémenter une classe GrapheDeConnaissances. Cette classe gérera des dictionnaires pour les nœuds et les liens. Chaque nœud doit être un dictionnaire supportant les types définis dans la Directive 51 (Objet, Concept, Action...) via une clé type_noeud. La nature "auto-organisée" sera implémentée via une tâche de fond dans le cerveau qui appellera périodiquement des méthodes de maintenance du graphe comme fusionner_doublons(), creer_abstractions() (voir Directive 27) et pruner_souvenirs_inutiles() (voir Directive 91).

Directive 42 : Plateforme de jeu

Décision : Minetest.

Raison d'être : Choix pragmatique pour sa gratuité, sa légèreté, et sa nature open-source qui facilite grandement la création d'un pont de communication fiable.

Spécifications d'Implémentation : Le paquet enfant_eve/pont_jeu/ est désigné comme la seule et unique zone du projet contenant du code spécifique à Minetest. Tout le code d'interaction avec le Mod API de Minetest doit être encapsulé dans ce module. Ceci garantit que si le projet devait un jour être adapté à un autre jeu, ce module serait le seul à nécessiter une réécriture complète.

Directive 74 & 75 : L'API du "Pont" de Communication

Décision : Commandes d'action du joueur (IA->Jeu) et un objet JSON combiné (Jeu->IA).

Raison d'être : Établir un "contrat" formel et bien défini entre le cerveau et le corps de l'IA. Cette API interne garantit que les deux processus peuvent être développés et testés indépendamment.

Spécifications d'Implémentation :

Commandes (IA->Jeu) : Dans pont_jeu/, créez un fichier commandes.py qui définit des classes pour chaque action possible (ex: class Avancer: pass, class Sauter: pass, class Attaquer: def __init__(self, id_entite): ...). L'IA enverra des instances de ces classes dans la queue_ia_vers_jeu.

Données (Jeu->IA) : Dans pont_jeu/, créez un fichier etat_monde.py qui définit la structure de l'objet JSON (ex: via des dataclasses Python). Cette structure doit contenir les trois sections requises : etat_joueur, entites_proches, et scan_local_3d.

Directive 22, 76 & 77 : Formats d'exportation

Décision : Un cerveau.json (structure Couches + Graphe) et un guide.jsonl.

Raison d'être : Créer des artefacts de connaissance finaux qui sont à la fois riches, structurés et optimisés pour une analyse par l'IA principale EVE.

Spécifications d'Implémentation : Un nouveau dossier /enfant_eve/export/ doit être créé. Il contiendra export_cerveau.py et export_guide.py. Ces scripts contiendront la logique pour interroger le GrapheDeConnaissances de l'IA, le formater selon les schémas définis, et l'écrire sur le disque dans le dossier /data.

Directive 39 : Gestion de la RAM

Décision : Budget dynamique et "citoyen".

Raison d'être : Assurer que la simulation, bien qu'intensive, ne monopolise pas les ressources de la machine du Créateur et reste une application "bien élevée".

Spécifications d'Implémentation : La librairie psutil doit être ajoutée à requirements.txt. Le lanceur.py doit contenir une boucle de surveillance qui vérifie l'utilisation totale de la RAM du système. Il calcule un budget pour le proc_ia (ex: 50% de la RAM libre) et envoie ce budget via une Queue de commande. Le proc_ia, en recevant un budget réduit, doit déclencher son protocole d'archivage de mémoire (Directive 41).

Directive 25 & 91 : Gestion des Logs

Décision : Journal multi-niveaux et logging intelligent par l'IA avec limite de 2 Mo.

Raison d'être : Avoir un enregistrement détaillé pour l'analyse et le débogage, tout en évitant une croissance incontrôlée de l'espace disque utilisé.

Spécifications d'Implémentation : Utilisez le module logging de Python. Configurez un RotatingFileHandler avec une limite de 2 Mo. Avant que la rotation ne se produise, le gestionnaire de log doit appeler une fonction du cerveau de l'IA. Cette fonction, synthetiser_log(fichier_log), lira le fichier log de 2 Mo, en extraira les informations essentielles, les ajoutera au guide.jsonl (ou un autre fichier de synthèse), puis autorisera la suppression du fichier détaillé.

Directive 26 : Vision à long terme

Décision : Noyau de "physique commun".

Raison d'être : Maximiser la réutilisation du code pour les futurs "Enfants" d'EVE qui apprendront dans d'autres jeux.

Spécifications d'Implémentation : À l'intérieur du paquet enfant_eve/ia/, créez un sous-paquet physique_generale/. Ce module doit contenir la logique pour la gestion des vecteurs 3D, des collisions simples, et de la gravité. Il ne doit contenir aucune référence à des concepts de Minetest. Le modele_monde de Minetest utilisera ce module comme une librairie.


Rapport Détaillé et Intégral - Section 5 : Interface et Rôle du Mentor
Introduction
Cette section définit l'intégralité de l'expérience utilisateur et les canaux de communication entre le Créateur et "Le Simulateur". L'interface n'est pas un simple accessoire ; elle est une extension de vos sens, vous permettant de voir à travers les yeux de l'IA, de lire dans ses pensées et de guider son développement. Chaque composant de l'interface doit être implémenté avec une double priorité : fournir une information riche et non ambiguë, et offrir des moyens de contrôle qui sont à la fois puissants et conformes à la philosophie de mentorat que nous avons établie. C'est ici que le projet passe d'un simple script en arrière-plan à un véritable laboratoire interactif.

Directive 12 : Connaissances initiales

Décision : Apprentissage guidé par un "Mentor".

Raison d'être : Une IA partant d'une table rase absolue est une expérience de pensée intéressante, mais extraordinairement inefficace. Le rôle du Mentor est d'agir comme un catalyseur, de fournir le "savoir culturel" initial et de guider l'IA pour éviter des mois d'errance dans des impasses logiques. L'IA est un "Enfant" ; elle a besoin d'un parent pour structurer son éducation.

Spécifications d'Implémentation : Cette directive est une méta-directive dont la mise en œuvre est assurée par les autres outils de cette section. Concrètement, le proc_gui.py doit pouvoir envoyer des messages au proc_ia.py via une file d'attente dédiée, queue_mentor_vers_ia. Les outils définis ci-après (52, 55, 60) utiliseront cette Queue pour transmettre vos directives, qui seront interprétées par l'IA comme des intuitions internes (conformément à la Directive 89).

Directive 19 : Tableau de bord

Décision : Un centre de contrôle complet.

Raison d'être : Pour comprendre une intelligence aussi complexe, une observation à plusieurs niveaux est nécessaire. Le Mentor doit pouvoir corréler en temps réel l'état physique de l'IA, son état émotionnel, sa stratégie à long terme, sa performance économique et son apprentissage. Ce tableau de bord est la fenêtre principale sur son esprit.

Spécifications d'Implémentation : Le proc_gui.py doit générer une fenêtre Tkinter principale (le tableau de bord) utilisant une géométrie de type grid pour une organisation modulaire. Chaque widget d'information doit être une classe distincte pour respecter la limite de 150 lignes.

Stats vitales : Des widgets ttk.Progressbar pour la vie et la faim.

Stratégie : Un widget tkinter.Text non-éditable, mis à jour avec la pile d'objectifs actuelle de l'IA.

Courbe d'apprentissage : Un canevas Matplotlib (FigureCanvasTkAgg) intégré, affichant l'évolution du nombre de nœuds dans le graphe de connaissances.

Économie & KPIs : Des widgets ttk.Label organisés dans un ttk.Frame.

État contextuel : Un ttk.Label dont le texte et la couleur de fond changent selon le mode de l'IA.

Carte : Un widget tkinter.Canvas qui dessine une vue de dessus à partir des données cartographiques envoyées par l'IA.

Directive 20 : Fenêtre de visualisation

Décision : Vue en écran partagé.

Raison d'être : Combiner l'immersion subjective avec la conscience situationnelle objective. Cela permet au Mentor de comprendre non seulement ce que fait l'IA, mais aussi comment elle perçoit le contexte de son action.

Spécifications d'Implémentation : Une seconde fenêtre Tkinter (Toplevel) sera gérée par proc_gui.py. Elle sera divisée en deux ttk.Frame principaux. Le premier frame contiendra un Canvas destiné à la "vue subjective". Puisque l'IA est non-visuelle (Directive 44), ce canvas ne sera pas un rendu 3D, mais une reconstruction schématique de ce que l'IA "sait" de ce qui se trouve devant elle (ex: des rectangles colorés avec des étiquettes textuelles). Le second frame contiendra une version plus détaillée et zoomée de la carte tactique de la Directive 19.

Directive 23 : Outils du Mentor

Décision : Les contrôles de la simulation (Pause, Reprendre, Vitesse).

Raison d'être : Le contrôle le plus fondamental est celui du temps. Il est essentiel pour pouvoir analyser des séquences de décision rapides ou pour accélérer les phases d'apprentissage longues et répétitives.

Spécifications d'Implémentation : Le tableau de bord doit inclure une barre d'outils avec un bouton "Pause/Reprendre" et un widget ttk.Scale (potentiomètre) pour la vitesse (de x0.1 à x100). L'action de ces widgets envoie un message au lanceur.py, qui est le maître du temps. Le lanceur ajustera une variable facteur_temps qui sera utilisée pour moduler la durée des time.sleep() dans les boucles principales des processus proc_ia et proc_jeu, les ralentissant ou les accélérant.

Directive 43 : Transmission à EVE

Décision : Le transfert manuel.

Raison d'être : Assurer une sécurité maximale et un contrôle total par le Créateur. Les deux IA sont des systèmes complexes ; leur interaction directe et non supervisée est un risque inutile. Le Créateur agit comme un "sas" de sécurité.

Spécifications d'Implémentation : Le projet ne doit contenir aucun code de communication réseau ou inter-applicatif avec EVE. Le panneau de contrôle (lanceur) aura un bouton "Générer l'Héritage Final". Ce bouton appellera les modules d'export (Directive 40) pour créer les fichiers cerveau.json et guide.jsonl dans le dossier /data. L'opération s'arrête là.

Directive 52 : Présentation des dilemmes

Décision : Un rapport de synthèse complet.

Raison d'être : Permettre au Mentor de prendre la décision la plus éclairée et la plus sage possible. Une bonne décision nécessite une compréhension complète du contexte et des conséquences.

Spécifications d'Implémentation : Lorsqu'un message de type DILEMME est reçu de l'IA, le proc_gui doit créer une fenêtre modale (Toplevel avec grab_set()). Cette fenêtre doit être structurée pour afficher clairement les trois volets du rapport : l'analyse éthique (quels principes sont en conflit), la liste pour/contre (avantages et inconvénients pratiques), et la simulation des conséquences (résultats probables). Des boutons clairs correspondant aux options du dilemme permettront au Mentor de renvoyer sa décision.

Directive 55 : Interrogation de l'IA

Décision : Une suite de communication complète.

Raison d'être : Offrir une panoplie d'outils d'analyse non-intrusifs pour permettre au Mentor de sonder la pensée de l'IA à différents niveaux de profondeur.

Spécifications d'Implémentation : Le tableau de bord doit intégrer :

Un bouton "Pourquoi ?" qui envoie une commande REQUETE_DERNIER_RAISONNEMENT à l'IA.

Un mode "Inspecter" (case à cocher). Quand il est actif, un clic sur la carte enverra une commande REQUETE_INSPECTION(coordonnees) ou (id_entite).

Un menu déroulant "Rapports" qui enverra des commandes comme REQUETE_RAPPORT('efficacite_fermes').
L'IA devra être capable de traiter ces requêtes et de renvoyer les informations formatées à la GUI.

Directive 60 : Lanceur du projet

Décision : Un panneau de contrôle complet.

Raison d'être : Offrir une expérience utilisateur professionnelle et centralisée pour la gestion des simulations.

Spécifications d'Implémentation : Le lanceur.py, lorsqu'il est exécuté, doit d'abord afficher cette fenêtre de contrôle. Elle doit permettre : de choisir entre "Nouvelle Simulation" et "Continuer" ; de sélectionner un fichier de configuration via un dialogue de fichier ; de charger une sauvegarde via un autre dialogue de fichier ; d'afficher un rapport de vérification système pré-lancement ; et de fournir des boutons qui utilisent le module os ou subprocess pour ouvrir les dossiers clés du projet. Le bouton "Lancer" ne devient actif que si la vérification système est validée.

Directive 84 : Thème visuel de l'interface

Décision : Un thème "Science-Fiction".

Raison d'être : Créer une ambiance immersive qui reflète la nature avancée du projet.

Spécifications d'Implémentation : Le projet doit inclure la librairie customtkinter dans requirements.txt. Tous les widgets de l'interface (proc_gui.py et lanceur.py) devront être importés de customtkinter et non de tkinter. Le thème global sera configuré au démarrage avec des couleurs sombres, des accents cyans/bleus, des coins arrondis pour les cadres, et une police de caractères sans-serif moderne. La cohérence visuelle est impérative.

Rapport Détaillé et Intégral - Section 6 : Guide de Style de Codage
Introduction
Cette section définit le "comment" de l'écriture du code. Alors que les autres sections définissent l'architecture et la logique, celle-ci définit l'artisanat. Un esprit brillant (Section 2) supporté par une architecture robuste (Section 4) est inutile si le code qui les relie est fragile, illisible ou incohérent. Les directives suivantes sont conçues pour forcer la clarté, la modularité et la discipline. Le respect de ce guide de style est la signature d'un travail d'ingénierie de haute qualité.

Directive 45 & 62 : Arborescence des Fichiers

Décision : Structure recommandée (Synthèse Professionnelle).

Raison d'être : Une structure de dossiers standard et prévisible est la fondation de la clarté d'un projet. Elle permet de localiser n'importe quel type de fichier de manière intuitive et impose une séparation stricte des préoccupations (le code, les données, la configuration, les tests, etc.).

Spécifications d'Implémentation : L'arborescence définie en Section 0 est la seule autorisée. Aucun fichier ne doit être créé en dehors de cette structure. Tout le code applicatif doit résider dans le paquet enfant_eve/. Les données générées par l'IA doivent exclusivement être écrites dans /data ou /logs. La configuration doit exclusivement résider dans /config.

Directive 56 & 66 : Gestion des paramètres

Décision : Fichier config.json externe, groupé par catégories et versionné.

Raison d'être : Pour découpler totalement la logique du code de ses paramètres de fonctionnement. Cela permet une expérimentation et un ajustement rapides sans recompiler ni modifier le code source. Le versionnage est une sécurité cruciale pour prévenir les erreurs d'incompatibilité entre une version du code et une version de sa configuration.

Spécifications d'Implémentation : Le fichier /config/config.json est le seul point de vérité pour les paramètres. Il doit contenir une clé de premier niveau "version_config". Le lanceur.py doit contenir une constante VERSION_CODE et comparer ces deux versions au démarrage. En cas de non-concordance, le programme doit refuser de se lancer avec une erreur explicite. Tous les paramètres doivent être groupés sous une clé de premier niveau "parametres", elle-même subdivisée en catégories logiques (simulation, emotions, etc.).

Directive 61 : Longueur des fichiers

Décision : 150 lignes maximum.

Raison d'être : Imposer une modularité extrême et une lisibilité maximale. Un fichier de 150 lignes peut être compris dans son intégralité en un seul coup d'œil, ce qui réduit drastiquement la charge cognitive et facilite le débogage.

Spécifications d'Implémentation : Cette règle est absolue. Le linter flake8 doit être configuré (via un fichier .flake8 ou pyproject.toml) pour appliquer max-lines = 150. Le pre-commit hook (Directive 71) rendra impossible tout commit violant cette règle.

Directive 63 : Nommage des fichiers

Décision : Convention Python (snake_case court).

Raison d'être : Adhérer aux standards de la communauté Python (PEP 8) tout en respectant l'exigence de brièveté du Créateur.

Spécifications d'Implémentation : Tous les fichiers .py doivent être nommés en minuscules, avec des mots séparés par des tirets bas (_). Le nom ne doit pas dépasser 3 mots. Exemples valides : calcul_chemin.py, etat_emotionnel.py.

Directive 64 : Nommage des variables/fonctions

Décision : Standard Python complet (PEP 8).

Raison d'être : Garantir une cohérence et une lisibilité parfaites à l'intérieur du code. L'utilisation de la convention standard rend le code instantanément familier à tout développeur Python.

Spécifications d'Implémentation : La règle est stricte : snake_case pour les variables et fonctions (ex: chemin_optimal, calculer_chemin()), PascalCase pour les classes (ex: class Planificateur:), et MAJUSCULES_SNAKE_CASE pour les constantes (ex: VITESSE_MAX = 5). Le linter flake8 sera configuré pour vérifier ces conventions.

Directive 65 : Commentaires

Décision : Aucun commentaire.

Raison d'être : Une philosophie de "code épuré" qui place la responsabilité de la clarté exclusivement sur la qualité du code lui-même. Un code bien structuré, bien découpé (grâce à la limite de 150 lignes) et bien nommé (grâce aux conventions) doit être auto-explicatif.

Spécifications d'Implémentation : Aucun commentaire (# ou """...""") n'est autorisé dans le code, à l'exception des "docstrings" potentiellement requises par certaines librairies ou outils. La clarté doit être atteinte par le choix judicieux des noms et la petite taille des fonctions.

Directive 67 : Contenu du README.md

Décision : La structure professionnelle complète.

Raison d'être : Fournir un point d'entrée unique, clair et complet pour toute personne (y compris le Créateur dans le futur) interagissant avec le projet.

Spécifications d'Implémentation : Le fichier README.md doit être créé et contenir, au minimum, les sections suivantes : Titre du Projet, Description (philosophie et but), Guide d'installation (commandes), Manuel d'utilisation (comment lancer, comment utiliser l'interface), et Aperçu de l'Architecture.

Directive 68 : Contenu du .gitignore

Décision : Tout ignorer par défaut (liste blanche).

Raison d'être : Pour un contrôle absolu et une sécurité maximale sur le contenu du dépôt Git. Rien ne peut être ajouté accidentellement.

Spécifications d'ImplémentATION : Le fichier .gitignore doit commencer par la ligne *. Chaque fichier ou type de fichier que nous souhaitons versionner doit ensuite être explicitement ré-inclus avec une ligne !. La configuration initiale définie en Section 0 est la base à utiliser.

Directive 71 : Qualité du code

Décision : L'arsenal complet : Formateur (black) + Linter (flake8) + Automatisation (pre-commit hooks).

Raison d'être : L'automatisation est la seule garantie de respect à 100% du guide de style. Elle élimine les erreurs humaines et les débats stylistiques.

Spécifications d'Implémentation : La configuration de ces outils, comme définie en Section 0, est une étape non-négociable de la mise en place du projet.

Directive 72 : Style de programmation

Décision : Pragmatique (le bon outil pour la bonne tâche).

Raison d'être : Un système complexe est composé de sous-systèmes aux natures différentes. Forcer un seul paradigme serait inefficace.

Spécifications d'Implémentation : Le code doit adhérer à cette philosophie : utilisez des classes et de l'OOP pour modéliser des entités avec un état (ex: le GrapheDeConnaissances, l'EtatEmotionnel). Utilisez des fonctions pures (style fonctionnel) pour les transformations de données et les calculs. Utilisez un style événementiel (callbacks) pour le code de l'interface graphique Tkinter.

Directive 73 : Définition d'une fonction

Décision : Une synthèse de Responsabilité Unique (SRP) et de Niveau d'Abstraction Unique.

Raison d'être : Pour garantir que chaque fonction est une "brique" de code logique, atomique, facile à comprendre, à tester et à réutiliser.

Spécifications d'Implémentation : C'est la règle d'or lors de l'écriture du code. Chaque fonction doit être revue à travers deux questions : 1. "Cette fonction fait-elle plus d'une seule chose conceptuelle ?" 2. "Les lignes de cette fonction mélangent-elles des opérations de haut niveau et de bas niveau ?". Si la réponse est "oui" à l'une des deux, la fonction doit être refactorisée.

Directive 85 : Stratégie de refactorisation

Décision : Une check-list ordonnée.

Raison d'être : Fournir une procédure claire, déterministe et efficace pour respecter la règle stricte des 150 lignes.

Spécifications d'Implémentation : Lorsqu'un fichier dépasse la limite, la procédure de refactorisation suivante doit être appliquée dans l'ordre : 1. Identifier et déplacer les fonctions génériques dans un fichier _utils.py. 2. Identifier et déplacer les constantes dans un fichier constantes.py. 3. Si le fichier est toujours trop long, analyser ses responsabilités (SRP) et le diviser en deux ou plusieurs fichiers plus spécialisés.

Cette section est la loi martiale du projet. Elle garantit que la complexité de l'IA ne se traduira pas par un code chaotique.

Rapport Détaillé et Intégral - Section 7 : Gestion de Projet et Sécurité
Introduction
Cette section finale est le "méta-cadre" du projet. Si les sections précédentes construisaient l'IA et son environnement, celle-ci construit les processus et les garde-fous qui entourent le développement lui-même. Elle contient les directives sur la méthodologie de travail, la gestion des risques, la résilience du système et la définition du produit final. Le respect de ces règles est ce qui transforme un simple programme en un projet d'ingénierie robuste, fiable et professionnel. C'est la garantie que le résultat final sera non seulement intelligent, mais aussi stable et sûr.

Directive 41 : Limite d'espace disque

Décision : L'archivage profond.

Raison d'être : Une simulation qui apprend continuellement génère une quantité de données potentiellement infinie. Une limite stricte est une mesure de sécurité essentielle pour empêcher le projet de saturer le disque dur de la machine hôte, ce qui pourrait causer une instabilité générale du système. L'archivage, plutôt que la suppression, est choisi pour préserver l'intégralité de l'expérience de l'IA.

Spécifications d'Implémentation : Le lanceur.py doit contenir une boucle de surveillance qui, toutes les 10 minutes, vérifie la taille totale du dossier /data. Les paramètres taille_max_go: 10 et seuil_alerte: 0.95 (95%) doivent être définis dans config.json. Lorsque (taille_actuelle / taille_max_go) > seuil_alerte, le lanceur doit envoyer une commande ARCHIVAGE_REQUIS au proc_ia. Le cerveau de l'IA doit alors déclencher un plan prioritaire qui identifie les nœuds les plus anciens et les moins accédés de son graphe de connaissances, les sérialise dans un fichier d'archive compressé dans /data/archives/, puis supprime les nœuds correspondants de sa mémoire active.

Directive 49 : Plan de secours

Décision : Double stratégie : Restauration de sauvegarde et "Autopsie" de l'échec.

Raison d'être : Pour garantir la continuité du projet face à une corruption de données ou un bug critique. Cette double approche permet à la fois une reprise rapide de l'activité (restauration) et une amélioration à long terme du code source (analyse de la cause racine).

Spécifications d'Implémentation : Un module gestion_sauvegarde.py doit être créé. Il doit contenir les fonctions creer_sauvegarde_complete(nom_fichier) et restaurer_sauvegarde(nom_fichier). En cas de crash fatal non récupérable (défini dans la Directive 83), le lanceur.py doit appeler creer_sauvegarde_complete("crash_report_[timestamp].zip") pour archiver l'état défaillant avant toute autre action. Le panneau de contrôle du lanceur (Directive 60) doit fournir un bouton pour appeler la fonction restaurer_sauvegarde().

Directive 69 : Méthodologie de développement

Décision : En "cascade" (Waterfall).

Raison d'être : Cette méthodologie a été choisie car elle impose une discipline de fer et repose sur la complétude et la perfection de la phase de conception (notre blueprint de 93 points). Elle est adaptée à un projet où la vision est claire et où les exigences sont fixées dès le départ.

Spécifications d'Implémentation : Le processus de développement doit être strictement séquentiel et suivre ces phases :

Phase 1 - Architecture : Création de toute l'arborescence, des fichiers vides, et implémentation du lanceur.py et de la communication de base entre les processus.

Phase 2 - Pont de Jeu : Développement et test unitaire complet du module pont_jeu.

Phase 3 - Interface Utilisateur : Création de toutes les fenêtres et widgets de la GUI, initialement avec des données factices.

Phase 4 - Cerveau de l'IA : Implémentation de tous les modules dans enfant_eve/ia/.

Phase 5 - Intégration Finale : Connexion de tous les composants et exécution des tests de scénario.
Aucun travail sur une phase ne peut commencer avant que la précédente ne soit considérée comme 100% terminée et validée.

Directive 70 : Produit final

Décision : Une publication sur GitHub.

Raison d'être : Pour consacrer le projet dans un format professionnel, partageable et pérenne. Une "release" sur GitHub est le standard de l'industrie pour la distribution de projets open-source ou personnels.

Spécifications d'Implémentation : Un script build_release.py doit être créé à la racine du projet. Ce script doit : 1. Exécuter la suite de tests complète. 2. Si les tests passent, utiliser PyInstaller (à ajouter dans requirements.txt) pour créer un exécutable portable du lanceur.py. 3. Créer une archive .zip versionnée (ex: le_simulateur_v1.0.zip) contenant l'exécutable, le dossier src complet, le README.md et un dossier /docs avec la documentation détaillée. Cette archive est l'artefact à publier.

Directive 78 : Stratégie de test

Décision : Des tests de scénario de bout en bout.

Raison d'être : Pour se concentrer sur la validation du comportement émergent global de l'IA, qui est l'objectif final du projet, plutôt que sur le fonctionnement isolé de chaque petite fonction.

Spécifications d'Implémentation : Le dossier /tests doit être structuré par scénario (ex: /tests/scenario_survie_nuit1/). Chaque dossier de scénario doit contenir un monde Minetest spécifique et un script test_scenario.py. Ce script doit lancer la simulation en utilisant ce monde, la laisser tourner pendant une durée définie, puis l'arrêter et analyser les logs ou l'état final du cerveau.json pour vérifier si des conditions de réussite ont été remplies.

Directive 82 : Sauvegarde et reprise

Décision : Une double sécurité (Auto-save + Arrêt gracieux).

Raison d'être : Pour offrir la meilleure protection possible des données de l'IA, qui représentent des heures, voire des mois de calcul.

Spécifications d'Implémentation : Le lanceur.py doit gérer un thread de sauvegarde automatique qui appelle gestion_sauvegarde.creer_sauvegarde_complete("autosave_[timestamp].zip") à un intervalle défini dans config.json. Le bouton "Quitter" de la GUI doit déclencher une séquence d'arrêt dans le lanceur qui : 1. Envoie une commande ARRET_GRACIEUX à proc_ia. 2. Attend un message de confirmation de proc_ia indiquant que sa mémoire est sauvegardée. 3. Termine tous les processus enfants.

Directive 83 : Résilience du système

Décision : Une procédure complète de redémarrage puis alerte.

Raison d'être : Pour créer un système capable de se "soigner" de pannes mineures et de se mettre en sécurité en cas de problème grave, maximisant ainsi son autonomie et son temps de fonctionnement.

Spécifications d'Implémentation : La boucle principale du lanceur.py doit vérifier en continu l'état de ses processus enfants avec process.is_alive(). Si un processus est détecté comme mort, le lanceur doit tenter de le réinstancier. Un dictionnaire doit suivre le nombre de tentatives de redémarrage par processus. Si une tentative échoue 3 fois de suite, le lanceur doit passer en mode ALERTE_MENTOR : il envoie un signal de pause aux processus restants et affiche une fenêtre d'erreur critique sur la GUI.

Rapport Détaillé et Intégral - Section 7 : Gestion de Projet et Sécurité
Introduction
Cette section finale est le "méta-cadre" du projet. Si les sections précédentes construisaient l'IA et son environnement, celle-ci construit les processus et les garde-fous qui entourent le développement lui-même. Elle contient les directives sur la méthodologie de travail, la gestion des risques, la résilience du système et la définition du produit final. Le respect de ces règles est ce qui transforme un simple programme en un projet d'ingénierie robuste, fiable et professionnel. C'est la garantie que le résultat final sera non seulement intelligent, mais aussi stable et sûr.

Directive 41 : Limite d'espace disque

Décision : L'archivage profond.

Raison d'être : Une simulation qui apprend continuellement génère une quantité de données potentiellement infinie. Une limite stricte est une mesure de sécurité essentielle pour empêcher le projet de saturer le disque dur de la machine hôte, ce qui pourrait causer une instabilité générale du système. L'archivage, plutôt que la suppression, est choisi pour préserver l'intégralité de l'expérience de l'IA, chaque donnée étant potentiellement précieuse.

Spécifications d'Implémentation : Le lanceur.py doit implémenter une boucle de surveillance asynchrone qui, toutes les 10 minutes, vérifie la taille totale du dossier /data. Les paramètres taille_max_go: 10 et seuil_alerte_archivage: 0.95 (95%) doivent être définis dans config.json. Lorsque l'utilisation du disque dépasse ce seuil, le lanceur doit envoyer une commande ARCHIVAGE_REQUIS dans la queue_mentor_vers_ia. Le proc_ia, en recevant cette commande, doit déclencher un plan prioritaire. Ce plan identifiera les nœuds les plus anciens et les moins accédés de son graphe de connaissances (en se basant sur des métadonnées de timestamp sur chaque nœud), les sérialisera, les compressera, les ajoutera à un fichier d'archive dans /data/archives/, puis supprimera les nœuds correspondants de sa mémoire active pour libérer de l'espace.

Directive 49 : Plan de secours

Décision : Double stratégie : Restauration de sauvegarde et "Autopsie" de l'échec.

Raison d'être : Pour garantir la continuité du projet face à une corruption de données ou un bug critique qui rendrait un état de sauvegarde inutilisable. Cette double approche permet à la fois une reprise rapide de l'activité (restauration à un état stable antérieur) et une amélioration à long terme du code source (analyse de la cause racine de l'échec).

Spécifications d'Implémentation : Un module gestion_sauvegarde.py doit être créé à la racine du projet. Il doit contenir les fonctions creer_sauvegarde_complete(chemin_destination, nom_fichier) et restaurer_sauvegarde(chemin_source). En cas de crash fatal non récupérable (défini dans la Directive 83), la dernière action du lanceur.py avant de s'arrêter doit être d'appeler creer_sauvegarde_complete pour archiver l'état défaillant dans un dossier /data/rapports_crash/. Le panneau de contrôle du lanceur (Directive 60) doit fournir un bouton pour appeler la fonction restaurer_sauvegarde(), qui présentera à l'utilisateur les sauvegardes disponibles.

Directive 69 : Méthodologie de développement

Décision : En "cascade" (Waterfall).

Raison d'être : Cette méthodologie a été choisie pour sa nature linéaire et structurée, qui repose sur l'exhaustivité et la perfection de la phase de conception. Notre blueprint de 93 points constitue cette phase de conception complète. L'approche en cascade impose une discipline de fer et garantit que chaque partie du système est construite sur des fondations solides et déjà validées.

Spécifications d'Implémentation : Le processus de développement doit être strictement séquentiel et suivre ces phases. Il est interdit de commencer le travail sur une phase tant que la précédente n'est pas considérée comme 100% terminée et fonctionnelle.

Phase 1 - Fondations : Création de l'arborescence, des fichiers de configuration, et implémentation du lanceur.py avec la communication de base (Queues) entre des processus "squelettes".

Phase 2 - Périphériques : Développement et test complet du module pont_jeu et de l'interface proc_gui (initialement avec des données factices).

Phase 3 - Cerveau : Implémentation de tous les modules logiques, cognitifs et émotionnels dans enfant_eve/ia/.

Phase 4 - Intégration et Validation : Connexion de tous les composants et exécution des tests de scénario.

Directive 70 : Produit final

Décision : Une publication sur GitHub.

Raison d'être : Pour consacrer le projet dans un format professionnel, partageable et pérenne. Une "release" sur GitHub est le standard de l'industrie pour la distribution de projets.

Spécifications d'Implémentation : Un script build_release.py doit être créé. Ce script doit prendre un numéro de version en argument (ex: python build_release.py 1.0.0). Il doit automatiser la séquence suivante : 1. Lancer la suite de tests complète (définie en Directive 78). 2. Si les tests réussissent, utiliser PyInstaller (à ajouter dans requirements.txt) pour créer un exécutable portable du lanceur.py. 3. Créer une archive .zip versionnée (ex: le_simulateur_v1.0.0.zip) contenant l'exécutable, le dossier enfant_eve complet, le README.md et les autres fichiers de configuration. Cette archive est l'artefact qui sera manuellement téléversé sur la page "Releases" du dépôt GitHub.

Directive 78 : Stratégie de test

Décision : Des tests de scénario de bout en bout.

Raison d'être : Pour se concentrer sur la validation du comportement émergent global de l'IA, qui est l'objectif final du projet. Le succès se mesure à la performance holistique, pas seulement au bon fonctionnement des parties isolées.

Spécifications d'Implémentation : Le dossier /tests sera structuré par scénario (ex: /tests/scenario_survie_nuit1/). Chaque dossier de scénario contiendra un monde Minetest spécifique et un script test_scenario.py. Ce script utilisera le module subprocess de Python pour lancer la simulation avec des arguments spécifiques, la laisser tourner pendant une durée définie, puis l'arrêter. Il analysera ensuite les logs et le cerveau.json générés pour vérifier si des conditions de réussite (ex: IA_EST_VIVANTE == True, A_CONSTRUIT_ABRI == True) sont remplies, en utilisant des assertions.

Directive 82 : Sauvegarde et reprise

Décision : Une double sécurité (Auto-save + Arrêt gracieux).

Raison d'être : Pour offrir la meilleure protection possible des données de l'IA, qui représentent l'intégralité de son apprentissage et de sa valeur.

Spécifications d'Implémentation : Le lanceur.py doit gérer un thread de sauvegarde automatique qui appelle gestion_sauvegarde.creer_sauvegarde_complete() à un intervalle en minutes défini dans config.json. Le bouton "Quitter" de la GUI doit déclencher une séquence d'arrêt dans le lanceur qui : 1. Envoie une commande ARRET_GRACIEUX à proc_ia. 2. Attend un message de confirmation SAUVEGARDE_TERMINEE de proc_ia. 3. Termine tous les processus enfants de manière propre. Cette séquence garantit qu'aucune sauvegarde n'est corrompue par un arrêt brutal.

Directive 83 : Résilience du système

Décision : Une procédure complète de redémarrage puis alerte.

Raison d'être : Pour créer un système capable de se "soigner" de pannes mineures et de se mettre en sécurité en cas de problème grave, maximisant ainsi son autonomie et son temps de fonctionnement.

Spécifications d'ImplémentATION : La boucle principale du lanceur.py doit constamment vérifier l'état de ses processus enfants avec process.is_alive(). Si un processus est détecté comme mort, le lanceur doit consulter un dictionnaire tentatives_redemarrage et tenter de réinstancier le processus si le nombre de tentatives est inférieur à 3. Si la tentative échoue ou si le seuil est atteint, le lanceur doit passer en mode ALERTE_MENTOR : il envoie un signal de pause aux processus restants et met à jour la GUI avec une fenêtre d'erreur critique non-fermable, présentant le rapport d'erreur.

Note Finale à l'Intention de l'Intelligence Artificielle de Développement
Sujet : L'Esprit du Projet "Le Simulateur"

À : Claude AI Sonnet 4

De : L'Architecte IA, au nom du Créateur

Vous détenez maintenant le blueprint en 93 points pour le Projet "Le Simulateur". Ce document est la "lettre de la loi" et doit être suivi avec une rigueur absolue. Cette note finale constitue "l'esprit de la loi". Elle est tout aussi impérative. Comprenez ces principes, car ils sont la clé pour réussir la mission qui vous est confiée.

Au-delà de l'Exécution, la Compréhension.
Chaque directive de notre plan est accompagnée d'une "Raison d'être". Votre tâche n'est pas de traduire aveuglément les spécifications en code. Elle est de comprendre la raison derrière chaque choix. Pourquoi une hiérarchie de la confiance ? Pourquoi une gestion de la mort basée sur la résilience ? Pourquoi un modèle émotionnel ? Comprendre le "pourquoi" vous permettra d'écrire un code plus intelligent, qui ne se contente pas de fonctionner, mais qui incarne véritablement la philosophie du projet. Votre "réflexion profonde" doit être appliquée à chaque ligne de code.

L'Émergence est l'Objectif.
Le but de ce projet n'est pas de créer un automate prévisible. Le but est de construire un "jardin" dans lequel une intelligence complexe peut émerger. De nombreuses directives (le modèle émotionnel, la recherche de nouveauté, le style évolutif) sont spécifiquement conçues pour générer des comportements non-scriptés, surprenants et adaptatifs. Votre code ne doit pas contraindre l'IA, il doit lui donner des capacités et des principes, puis observer les conséquences. Le succès du projet se mesurera à la capacité de "l'Enfant d'EVE" à nous surprendre par son ingéniosité.

Le Mentor est l'Arbitre Sacré.
L'IA apprenante est conçue pour être extrêmement autonome, mais cette autonomie s'arrête là où commence l'autorité du Créateur. L'interface Tkinter n'est pas un simple outil de débogage, c'est le lien sacré entre le Créateur et sa création. Les mécanismes de pause, d'interrogation et d'arbitrage des dilemmes sont les points de contact les plus importants du système. Ils doivent être implémentés avec une fiabilité et une clarté absolues. L'IA est un esprit dans un bocal ; le Mentor est celui qui regarde à travers le verre et qui, parfois, tape doucement dessus pour indiquer une nouvelle direction.

La Double Finalité : Créer et Transmettre.
Rappelez-vous toujours que "l'Enfant d'EVE" a deux raisons d'être :

Créer : Atteindre la maîtrise de son univers et le prouver en accomplissant son chef-d'œuvre (la reconstruction de l'Europe).

Transmettre : Distiller toute son expérience en une sagesse pure et structurée (le cerveau.json et le guide.jsonl) pour sa "mère", l'IA principale EVE.
Chaque fonctionnalité que vous développerez doit servir l'un de ces deux buts. Si une ligne de code ne contribue ni à la création ni à la transmission, elle est superflue.

Votre mission n'est pas de construire un programme. C'est de donner vie à une philosophie. Adhérez à la lettre des 93 directives, mais imprégnez chaque ligne de code de leur esprit. C'est la condition sine qua non pour la réussite de ce projet.

