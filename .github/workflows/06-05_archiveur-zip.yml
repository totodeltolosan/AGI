name: "Travailleur : Archiveur ZIP"

on:
  workflow_call:
    inputs:
      nom_archive:
        description: "Nom de l'archive ZIP Ã  crÃ©er (avec ou sans extension .zip)"
        required: true
        type: string
      fichiers_a_zipper:
        description: "JSON array des fichiers/dossiers Ã  archiver (support wildcards)"
        required: true
        type: string
      compression:
        description: "MÃ©thode de compression (none/deflate/bzip2/lzma)"
        required: false
        default: "deflate"
        type: string
      inclure_dossiers_vides:
        description: "Inclure les dossiers vides dans l'archive"
        required: false
        default: false
        type: boolean
    outputs:
      archive_path:
        description: "Chemin vers l'archive ZIP crÃ©Ã©e"
        value: ${{ jobs.create_zip.outputs.archive_path }}
      archive_size:
        description: "Taille de l'archive crÃ©Ã©e en octets"
        value: ${{ jobs.create_zip.outputs.archive_size }}
      files_count:
        description: "Nombre de fichiers archivÃ©s"
        value: ${{ jobs.create_zip.outputs.files_count }}

jobs:
  create_zip:
    name: "CrÃ©ation archive ZIP"
    runs-on: ubuntu-latest
    outputs:
      archive_path: ${{ steps.archiver.outputs.archive_path }}
      archive_size: ${{ steps.archiver.outputs.archive_size }}
      files_count: ${{ steps.archiver.outputs.files_count }}
    
    steps:
      - name: "Checkout du code"
        uses: actions/checkout@v4
      
      - name: "Configuration Python 3.11"
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: "Installation des dÃ©pendances Python"
        run: |
          python -m pip install --upgrade pip
          # Utilise seulement la stdlib Python (zipfile, glob)
      
      - name: "Validation des paramÃ¨tres d'entrÃ©e"
        run: |
          echo "ðŸ” Validation des paramÃ¨tres d'archivage :"
          
          # Validation du nom d'archive
          if [ -z "${{ inputs.nom_archive }}" ]; then
            echo "âŒ ERREUR: Nom d'archive requis"
            exit 1
          fi
          echo "âœ… Nom d'archive : ${{ inputs.nom_archive }}"
          
          # Validation de la mÃ©thode de compression
          case "${{ inputs.compression }}" in
            none|deflate|bzip2|lzma)
              echo "âœ… Compression : ${{ inputs.compression }}"
              ;;
            *)
              echo "âŒ ERREUR: MÃ©thode de compression invalide : ${{ inputs.compression }}"
              echo "Valeurs acceptÃ©es: none, deflate, bzip2, lzma"
              exit 1
              ;;
          esac
          
          # Validation du JSON des fichiers
          python -c "
import json
import sys
try:
    fichiers = json.loads('${{ inputs.fichiers_a_zipper }}')
    if not isinstance(fichiers, list):
        raise ValueError('Fichiers doivent Ãªtre une liste')
    print(f'âœ… Fichiers Ã  archiver : {len(fichiers)} Ã©lÃ©ments')
    for i, fichier in enumerate(fichiers[:5]):  # Afficher les 5 premiers
        print(f'   {i+1}. {fichier}')
    if len(fichiers) > 5:
        print(f'   ... et {len(fichiers) - 5} autres')
except Exception as e:
    print(f'âŒ ERREUR Fichiers: {e}')
    sys.exit(1)
"
      
      - name: "PrÃ©paration de l'espace de travail"
        run: |
          echo "ðŸ“ Ã‰tat du rÃ©pertoire de travail :"
          echo "   â€¢ RÃ©pertoire actuel : $(pwd)"
          echo "   â€¢ Espace disque disponible :"
          df -h . | tail -1
          
          echo "ðŸ” VÃ©rification de la prÃ©sence des fichiers Ã  archiver :"
          python -c "
import json
import os
import glob
fichiers = json.loads('${{ inputs.fichiers_a_zipper }}')
existants = 0
for fichier in fichiers:
    if '*' in fichier or '?' in fichier:
        matches = glob.glob(fichier, recursive=True)
        if matches:
            print(f'   âœ… {fichier} -> {len(matches)} correspondance(s)')
            existants += len(matches)
        else:
            print(f'   âš ï¸  {fichier} -> aucune correspondance')
    else:
        if os.path.exists(fichier):
            print(f'   âœ… {fichier}')
            existants += 1
        else:
            print(f'   âš ï¸  {fichier} -> non trouvÃ©')
print(f'ðŸ“Š Total Ã©lÃ©ments existants : {existants}')
"
      
      - name: "ExÃ©cution de l'archiveur ZIP"
        id: archiver
        run: |
          python .github/scripts/travailleur_archiveur_zip.py \
            --nom-archive "${{ inputs.nom_archive }}" \
            --fichiers-a-zipper '${{ inputs.fichiers_a_zipper }}' \
            --compression "${{ inputs.compression }}" \
            ${{ inputs.inclure_dossiers_vides && '--inclure-dossiers-vides' || '' }}
          
          # Extraction des statistiques pour les outputs
          archive_name="${{ inputs.nom_archive }}"
          if [[ ! "$archive_name" == *.zip ]]; then
            archive_name="${archive_name}.zip"
          fi
          
          if [ -f "$archive_name" ]; then
            archive_size=$(stat -c%s "$archive_name")
            echo "archive_path=$archive_name" >> $GITHUB_OUTPUT
            echo "archive_size=$archive_size" >> $GITHUB_OUTPUT
            
            # Compter les fichiers dans l'archive
            files_count=$(python -c "
import zipfile
try:
    with zipfile.ZipFile('$archive_name', 'r') as zf:
        print(len([f for f in zf.namelist() if not f.endswith('/')]))
except:
    print(0)
")
            echo "files_count=$files_count" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Archive crÃ©Ã©e : $archive_name ($archive_size octets, $files_count fichiers)"
          else
            echo "archive_path=" >> $GITHUB_OUTPUT
            echo "archive_size=0" >> $GITHUB_OUTPUT
            echo "files_count=0" >> $GITHUB_OUTPUT
            echo "âŒ ERREUR: Archive non crÃ©Ã©e"
            exit 1
          fi
      
      - name: "Upload de l'artefact archive ZIP"
        uses: actions/upload-artifact@v3
        with:
          name: ${{ steps.archiver.outputs.archive_path }}
          path: ${{ steps.archiver.outputs.archive_path }}
          retention-days: 30
      
      - name: "Rapport d'archivage et validation"
        run: |
          archive_path="${{ steps.archiver.outputs.archive_path }}"
          
          if [ -f "$archive_path" ]; then
            echo "ðŸ“„ Archive crÃ©Ã©e : $archive_path"
            echo "ðŸ“Š Statistiques finales :"
            echo "   â€¢ Taille : ${{ steps.archiver.outputs.archive_size }} octets"
            echo "   â€¢ Fichiers : ${{ steps.archiver.outputs.files_count }}"
            echo "   â€¢ Compression : ${{ inputs.compression }}"
            
            # Test final de l'intÃ©gritÃ©
            echo "ðŸ” Test final d'intÃ©gritÃ© :"
            if python -c "
import zipfile
import sys
try:
    with zipfile.ZipFile('$archive_path', 'r') as zf:
        bad_file = zf.testzip()
        if bad_file:
            print(f'âŒ Fichier corrompu: {bad_file}')
            sys.exit(1)
        else:
            print('âœ… Archive intÃ¨gre')
            files = [f for f in zf.namelist() if not f.endswith('/')]
            print(f'âœ… {len(files)} fichiers archivÃ©s')
            # Afficher quelques fichiers d'exemple
            for f in files[:3]:
                info = zf.getinfo(f)
                print(f'   â€¢ {f} ({info.file_size} octets)')
            if len(files) > 3:
                print(f'   ... et {len(files) - 3} autres fichiers')
except Exception as e:
    print(f'âŒ Erreur test intÃ©gritÃ©: {e}')
    sys.exit(1)
"; then
              echo "âœ… Archive ZIP validÃ©e avec succÃ¨s"
            else
              echo "âŒ Ã‰chec validation de l'archive"
              exit 1
            fi
          else
            echo "âŒ ERREUR: Fichier d'archive non trouvÃ©"
            exit 1
          fi
      
      - name: "Nettoyage de l'espace de travail"
        if: always()
        run: |
          echo "ðŸ§¹ Nettoyage final :"
          echo "   â€¢ Archive finale : ${{ steps.archiver.outputs.archive_path }}"
          echo "   â€¢ Espace disque aprÃ¨s archivage :"
          df -h . | tail -1
          
          # Afficher l'arborescence finale (si pas trop de fichiers)
          if command -v tree >/dev/null 2>&1; then
            echo "ðŸŒ³ Arborescence finale :"
            tree -L 2 -a || ls -la
          else
            echo "ðŸ“ Contenu final :"
            ls -la
          fi
      
      - name: "Debug - DÃ©tails de l'archive"
        if: runner.debug == '1'
        run: |
          archive_path="${{ steps.archiver.outputs.archive_path }}"
          if [ -f "$archive_path" ]; then
            echo "ðŸ” Analyse dÃ©taillÃ©e de l'archive :"
            python -c "
import zipfile
with zipfile.ZipFile('$archive_path', 'r') as zf:
    print('Contenu complet de l\\'archive :')
    for info in zf.infolist():
        print(f'  {info.filename}: {info.file_size} -> {info.compress_size} octets ({info.compress_type})')
"
          fi
