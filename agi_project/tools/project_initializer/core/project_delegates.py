#!/usr/bin/env python3
"""
Project Delegates - Interface Principale pour D√©l√©gation d'Op√©rations AGI
==========================================================================

CHEMIN: tools/project_initializer/core/project_delegates.py

Version corrig√©e avec bonnes m√©thodes PathValidator
"""

import os
from pathlib import Path
from typing import Dict, List, Any, Optional, Set, Tuple
import traceback

try:
    from .delegates_helpers import DelegatesHelpers
    from .delegates_config import DelegatesConfig
except ImportError as e:
    try:
        from delegates_helpers import DelegatesHelpers
        from delegates_config import DelegatesConfig
    except ImportError:
        raise ImportError(f"‚ùå Modules delegates refactoris√©s introuvables: {e}")


class ProjectDelegates:
    """D√©l√©gu√© principal pour op√©rations complexes de projet AGI."""

    def __init__(self, logger, orchestrator):
        """Initialise le d√©l√©gu√© avec logger et r√©f√©rence √† l'orchestrateur."""
        self.logger = logger
        self.orchestrator = orchestrator
        self.helpers = DelegatesHelpers(logger)
        self.config = DelegatesConfig()
        self.operation_cache: Dict[str, Any] = {}
        self.delegation_stats = {'operations': 0, 'successes': 0, 'errors': 0}

    def validate_project_inputs(self, output_dir: str, agi_md_path: str) -> bool:
        """Valide les param√®tres d'entr√©e du projet avec PathValidator correct."""
        try:
            self.logger.info(f"üîç Validation inputs: {output_dir}")
            
            # Utilisation correcte de PathValidator avec les vraies m√©thodes
            if hasattr(self.orchestrator, 'path_validator') and self.orchestrator.path_validator:
                try:
                    # Utiliser validate_safe_path (m√©thode qui existe)
                    safe_path_result = self.orchestrator.path_validator.validate_safe_path(output_dir)
                    if not safe_path_result:
                        self.logger.error(f"‚ùå Chemin non s√©curis√©: {output_dir}")
                        return False
                    
                    # Utiliser validate_directory_creation (m√©thode qui existe)
                    dir_creation_result = self.orchestrator.path_validator.validate_directory_creation(output_dir)
                    if not dir_creation_result:
                        self.logger.error(f"‚ùå Cr√©ation r√©pertoire impossible: {output_dir}")
                        return False
                    
                    self.logger.info("‚úÖ Validation PathValidator r√©ussie")
                    
                except Exception as validator_error:
                    self.logger.warning(f"‚ö†Ô∏è Erreur PathValidator, fallback: {validator_error}")
                    # Continuer avec validation basique
            
            # Validation basique en fallback ou compl√©ment
            output_path = Path(output_dir)
            
            # Cr√©er le r√©pertoire parent si n√©cessaire
            try:
                output_path.parent.mkdir(parents=True, exist_ok=True)
            except Exception as e:
                self.logger.error(f"‚ùå Impossible de cr√©er r√©pertoire parent: {e}")
                return False
            
            # V√©rifier permissions
            if not os.access(output_path.parent, os.W_OK):
                self.logger.error(f"‚ùå Pas de permission d'√©criture: {output_path.parent}")
                return False
            
            self.logger.info("‚úÖ Validation inputs r√©ussie")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur validation inputs: {e}")
            return False

    def parse_agi_report(self, agi_md_path: str) -> Dict[str, Any]:
        """Parse le rapport AGI.md via l'orchestrateur."""
        try:
            self.logger.info("üìñ Parsing AGI.md")
            
            # Utilisation du parser de l'orchestrateur si disponible
            if hasattr(self.orchestrator, 'agi_parser') and self.orchestrator.agi_parser:
                try:
                    result = self.orchestrator.agi_parser.parse_report()
                    self.logger.info(f"‚úÖ Parsing r√©ussi: {len(result.get('domains', []))} domaines")
                    return result
                except Exception as parser_error:
                    self.logger.warning(f"‚ö†Ô∏è Erreur parser AGI, fallback: {parser_error}")
            
            # Fallback avec domaines par d√©faut
            fallback_result = {
                'domains': ['core', 'compliance', 'supervisor', 'generators', 'integration'],
                'project_name': 'Projet AGI',
                'version': '1.0',
                'description': 'Projet AGI g√©n√©r√© automatiquement',
                'architecture': 'Modulaire'
            }
            
            self.logger.info(f"‚úÖ Parsing fallback: {len(fallback_result['domains'])} domaines")
            return fallback_result
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur parsing AGI.md: {e}")
            return {
                'domains': ['core', 'compliance'],
                'project_name': 'AGI Fallback',
                'version': '1.0'
            }

    def generate_all_files(
        self, output_dir: str, project_spec: Dict[str, Any], 
        excluded_domains: List[str], included_domains: List[str]
    ) -> bool:
        """G√©n√®re tous les fichiers du projet."""
        try:
            self.logger.info("üöÄ D√©marrage g√©n√©ration compl√®te")
            
            # Filtrage des domaines
            all_domains = project_spec.get('domains', ['core', 'compliance'])
            domains = self._filter_domains(all_domains, excluded_domains, included_domains)
            
            self.logger.info(f"üìÅ Domaines √† g√©n√©rer: {domains}")
            
            # G√©n√©ration Python via orchestrateur
            python_success = self._generate_python_files(output_dir, domains, project_spec)
            
            # G√©n√©ration des autres fichiers (non-bloquant)
            json_success = self._generate_json_files(output_dir, project_spec)
            markdown_success = self._generate_markdown_files(output_dir, project_spec)
            
            # Le succ√®s est bas√© principalement sur Python
            overall_success = python_success
            
            if overall_success:
                self.logger.info("‚úÖ G√©n√©ration compl√®te r√©ussie")
            else:
                self.logger.warning("‚ö†Ô∏è G√©n√©ration avec erreurs")
            
            return overall_success
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur g√©n√©ration compl√®te: {e}")
            return False

    def get_python_files_for_domain(self, domain: str) -> List[str]:
        """R√©cup√®re la liste des fichiers Python pour un domaine."""
        try:
            files = self.helpers.get_domain_python_files(domain)
            return files
        except Exception as e:
            self.logger.error(f"‚ùå Erreur r√©cup√©ration fichiers {domain}: {e}")
            return ['__init__.py', f'{domain}_manager.py']

    def _filter_domains(
        self, all_domains: List[str], excluded: List[str], included: List[str]
    ) -> List[str]:
        """Filtre les domaines selon les crit√®res."""
        if included:
            filtered = [d for d in all_domains if d in included]
            self.logger.info(f"üîç Filtrage par inclusion: {filtered}")
            return filtered
        if excluded:
            filtered = [d for d in all_domains if d not in excluded]
            self.logger.info(f"üîç Filtrage par exclusion: {filtered}")
            return filtered
        return all_domains

    def _generate_python_files(self, output_dir: str, domains: List[str], project_spec: Dict[str, Any]) -> bool:
        """G√©n√®re les fichiers Python."""
        try:
            success_count = 0
            
            if hasattr(self.orchestrator, 'python_generator') and self.orchestrator.python_generator:
                # G√©n√©ration par domaine
                for domain in domains:
                    try:
                        if self.orchestrator.python_generator.generate_domain_files(output_dir, domain, project_spec):
                            success_count += 1
                            self.logger.info(f"‚úÖ Domaine {domain}: fichiers g√©n√©r√©s")
                        else:
                            self.logger.warning(f"‚ö†Ô∏è Domaine {domain}: √©chec g√©n√©ration")
                    except Exception as domain_error:
                        self.logger.error(f"‚ùå Erreur domaine {domain}: {domain_error}")
                
                # G√©n√©ration du main.py
                try:
                    main_success = self.orchestrator.python_generator.generate_main_file(output_dir, project_spec)
                    if main_success:
                        self.logger.info("‚úÖ main.py g√©n√©r√©")
                    else:
                        self.logger.warning("‚ö†Ô∏è main.py √©chec")
                except Exception as main_error:
                    self.logger.error(f"‚ùå Erreur main.py: {main_error}")
                    main_success = False
                
                total_success = success_count > 0 or main_success
                self.logger.info(f"üêç Python: {success_count}/{len(domains)} domaines, main.py: {main_success}")
                return total_success
            
            self.logger.error("‚ùå Pas de g√©n√©rateur Python disponible")
            return False
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur g√©n√©ration Python: {e}")
            return False

    def _generate_json_files(self, output_dir: str, project_spec: Dict[str, Any]) -> bool:
        """G√©n√®re les fichiers JSON si disponible."""
        try:
            if hasattr(self.orchestrator, 'json_generator') and self.orchestrator.json_generator:
                success = self.orchestrator.json_generator.generate_rules_json(Path(output_dir))
                self.logger.info(f"üìÑ JSON: {'‚úÖ r√©ussi' if success else '‚ö†Ô∏è √©chec'}")
                return success
            
            self.logger.info("üìÑ JSON: g√©n√©rateur non disponible (non-bloquant)")
            return True
            
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erreur g√©n√©ration JSON (non-bloquant): {e}")
            return True

    def _generate_markdown_files(self, output_dir: str, project_spec: Dict[str, Any]) -> bool:
        """G√©n√®re les fichiers Markdown si disponible."""
        try:
            if hasattr(self.orchestrator, 'markdown_generator') and self.orchestrator.markdown_generator:
                success = self.orchestrator.markdown_generator.generate_main_readme(Path(output_dir))
                self.logger.info(f"üìù Markdown: {'‚úÖ r√©ussi' if success else '‚ö†Ô∏è √©chec'}")
                return success
            
            self.logger.info("üìù Markdown: g√©n√©rateur non disponible (non-bloquant)")
            return True
            
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erreur g√©n√©ration Markdown (non-bloquant): {e}")
            return True

    def get_delegation_stats(self) -> Dict[str, Any]:
        """Retourne les statistiques de d√©l√©gation."""
        return self.delegation_stats.copy()

    def __str__(self) -> str:
        """TODO: Add docstring."""
        return f"ProjectDelegates(operations={self.delegation_stats['operations']})"

    """TODO: Add docstring."""
    def __repr__(self) -> str:
        return f"ProjectDelegates(helpers={self.helpers}, config={self.config})"